{"ast":null,"code":"import _arity from \"./internal/_arity.js\";\nimport _curry2 from \"./internal/_curry2.js\";\nimport _has from \"./internal/_has.js\";\n/**\r\n * Creates a new function that, when invoked, caches the result of calling `fn`\r\n * for a given argument set and returns the result. Subsequent calls to the\r\n * memoized `fn` with the same argument set will not result in an additional\r\n * call to `fn`; instead, the cached result for that set of arguments will be\r\n * returned.\r\n *\r\n *\r\n * @func\r\n * @memberOf R\r\n * @since v0.24.0\r\n * @category Function\r\n * @sig (*... -> String) -> (*... -> a) -> (*... -> a)\r\n * @param {Function} fn The function to generate the cache key.\r\n * @param {Function} fn The function to memoize.\r\n * @return {Function} Memoized version of `fn`.\r\n * @example\r\n *\r\n *      let count = 0;\r\n *      const factorial = R.memoizeWith(R.identity, n => {\r\n *        count += 1;\r\n *        return R.product(R.range(1, n + 1));\r\n *      });\r\n *      factorial(5); //=> 120\r\n *      factorial(5); //=> 120\r\n *      factorial(5); //=> 120\r\n *      count; //=> 1\r\n */\n\nvar memoizeWith = /*#__PURE__*/_curry2(function memoizeWith(mFn, fn) {\n  var cache = {};\n  return _arity(fn.length, function () {\n    var key = mFn.apply(this, arguments);\n\n    if (!_has(key, cache)) {\n      cache[key] = fn.apply(this, arguments);\n    }\n\n    return cache[key];\n  });\n});\n\nexport default memoizeWith;","map":{"version":3,"sources":["D:/Lianok/dev/new-project/node_modules/ramda/es/memoizeWith.js"],"names":["_arity","_curry2","_has","memoizeWith","mFn","fn","cache","length","key","apply","arguments"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,sBAAnB;AACA,OAAOC,OAAP,MAAoB,uBAApB;AACA,OAAOC,IAAP,MAAiB,oBAAjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,WAAW,GACf,aACAF,OAAO,CAAC,SAASE,WAAT,CAAqBC,GAArB,EAA0BC,EAA1B,EAA8B;AACpC,MAAIC,KAAK,GAAG,EAAZ;AACA,SAAON,MAAM,CAACK,EAAE,CAACE,MAAJ,EAAY,YAAY;AACnC,QAAIC,GAAG,GAAGJ,GAAG,CAACK,KAAJ,CAAU,IAAV,EAAgBC,SAAhB,CAAV;;AAEA,QAAI,CAACR,IAAI,CAACM,GAAD,EAAMF,KAAN,CAAT,EAAuB;AACrBA,MAAAA,KAAK,CAACE,GAAD,CAAL,GAAaH,EAAE,CAACI,KAAH,CAAS,IAAT,EAAeC,SAAf,CAAb;AACD;;AAED,WAAOJ,KAAK,CAACE,GAAD,CAAZ;AACD,GARY,CAAb;AASD,CAXM,CAFP;;AAeA,eAAeL,WAAf","sourcesContent":["import _arity from \"./internal/_arity.js\";\r\nimport _curry2 from \"./internal/_curry2.js\";\r\nimport _has from \"./internal/_has.js\";\r\n/**\r\n * Creates a new function that, when invoked, caches the result of calling `fn`\r\n * for a given argument set and returns the result. Subsequent calls to the\r\n * memoized `fn` with the same argument set will not result in an additional\r\n * call to `fn`; instead, the cached result for that set of arguments will be\r\n * returned.\r\n *\r\n *\r\n * @func\r\n * @memberOf R\r\n * @since v0.24.0\r\n * @category Function\r\n * @sig (*... -> String) -> (*... -> a) -> (*... -> a)\r\n * @param {Function} fn The function to generate the cache key.\r\n * @param {Function} fn The function to memoize.\r\n * @return {Function} Memoized version of `fn`.\r\n * @example\r\n *\r\n *      let count = 0;\r\n *      const factorial = R.memoizeWith(R.identity, n => {\r\n *        count += 1;\r\n *        return R.product(R.range(1, n + 1));\r\n *      });\r\n *      factorial(5); //=> 120\r\n *      factorial(5); //=> 120\r\n *      factorial(5); //=> 120\r\n *      count; //=> 1\r\n */\r\n\r\nvar memoizeWith =\r\n/*#__PURE__*/\r\n_curry2(function memoizeWith(mFn, fn) {\r\n  var cache = {};\r\n  return _arity(fn.length, function () {\r\n    var key = mFn.apply(this, arguments);\r\n\r\n    if (!_has(key, cache)) {\r\n      cache[key] = fn.apply(this, arguments);\r\n    }\r\n\r\n    return cache[key];\r\n  });\r\n});\r\n\r\nexport default memoizeWith;"]},"metadata":{},"sourceType":"module"}