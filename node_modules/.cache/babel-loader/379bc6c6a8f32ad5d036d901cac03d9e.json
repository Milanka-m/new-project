{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AssignablePublicKey = void 0;\n\nconst solanaBorsh_1 = require(\"./solanaBorsh\");\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n/**\r\n * A Borsh-compatible public key object\r\n *\r\n * The pattern for these objects is to have their properties dynamically\r\n * assigned by borsh.decode, as opposed to via a constructor.\r\n *\r\n * The imperative assignment operator (!) is used to avoid Typescript\r\n * complaining about the above.\r\n */\n\n\nclass AssignablePublicKey extends solanaBorsh_1.Assignable {\n  toPublicKey() {\n    return new web3_js_1.PublicKey(this.bytes);\n  }\n\n  toString() {\n    return this.toPublicKey().toBase58();\n  }\n\n  static parse(pubkey) {\n    return AssignablePublicKey.fromPublicKey(new web3_js_1.PublicKey(pubkey));\n  }\n\n  static fromPublicKey(publicKey) {\n    return new AssignablePublicKey({\n      bytes: Uint8Array.from(publicKey.toBuffer())\n    });\n  }\n\n  static empty() {\n    const bytes = new Array(32);\n    bytes.fill(0);\n    return new AssignablePublicKey({\n      bytes\n    });\n  }\n\n}\n\nexports.AssignablePublicKey = AssignablePublicKey;\nsolanaBorsh_1.SCHEMA.set(AssignablePublicKey, {\n  kind: \"struct\",\n  fields: [[\"bytes\", [32]]]\n});","map":{"version":3,"sources":["../../src/lib/AssignablePublicKey.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;AAEA;;;;;;;;AAQG;;;AACH,MAAa,mBAAb,SAAyC,aAAA,CAAA,UAAzC,CAAmD;AAIjD,EAAA,WAAW,GAAA;AACT,WAAO,IAAI,SAAA,CAAA,SAAJ,CAAc,KAAK,KAAnB,CAAP;AACD;;AAED,EAAA,QAAQ,GAAA;AACN,WAAO,KAAK,WAAL,GAAmB,QAAnB,EAAP;AACD;;AAEW,SAAL,KAAK,CAAC,MAAD,EAAe;AACzB,WAAO,mBAAmB,CAAC,aAApB,CAAkC,IAAI,SAAA,CAAA,SAAJ,CAAc,MAAd,CAAlC,CAAP;AACD;;AAEmB,SAAb,aAAa,CAAC,SAAD,EAAqB;AACvC,WAAO,IAAI,mBAAJ,CAAwB;AAC7B,MAAA,KAAK,EAAE,UAAU,CAAC,IAAX,CAAgB,SAAS,CAAC,QAAV,EAAhB;AADsB,KAAxB,CAAP;AAGD;;AAEW,SAAL,KAAK,GAAA;AACV,UAAM,KAAK,GAAG,IAAI,KAAJ,CAAU,EAAV,CAAd;AACA,IAAA,KAAK,CAAC,IAAN,CAAW,CAAX;AACA,WAAO,IAAI,mBAAJ,CAAwB;AAAE,MAAA;AAAF,KAAxB,CAAP;AACD;;AA1BgD;;AAAnD,OAAA,CAAA,mBAAA,GAAA,mBAAA;AA6BA,aAAA,CAAA,MAAA,CAAO,GAAP,CAAW,mBAAX,EAAgC;AAC9B,EAAA,IAAI,EAAE,QADwB;AAE9B,EAAA,MAAM,EAAE,CAAC,CAAC,OAAD,EAAU,CAAC,EAAD,CAAV,CAAD;AAFsB,CAAhC","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AssignablePublicKey = void 0;\r\nconst solanaBorsh_1 = require(\"./solanaBorsh\");\r\nconst web3_js_1 = require(\"@solana/web3.js\");\r\n/**\r\n * A Borsh-compatible public key object\r\n *\r\n * The pattern for these objects is to have their properties dynamically\r\n * assigned by borsh.decode, as opposed to via a constructor.\r\n *\r\n * The imperative assignment operator (!) is used to avoid Typescript\r\n * complaining about the above.\r\n */\r\nclass AssignablePublicKey extends solanaBorsh_1.Assignable {\r\n    toPublicKey() {\r\n        return new web3_js_1.PublicKey(this.bytes);\r\n    }\r\n    toString() {\r\n        return this.toPublicKey().toBase58();\r\n    }\r\n    static parse(pubkey) {\r\n        return AssignablePublicKey.fromPublicKey(new web3_js_1.PublicKey(pubkey));\r\n    }\r\n    static fromPublicKey(publicKey) {\r\n        return new AssignablePublicKey({\r\n            bytes: Uint8Array.from(publicKey.toBuffer()),\r\n        });\r\n    }\r\n    static empty() {\r\n        const bytes = new Array(32);\r\n        bytes.fill(0);\r\n        return new AssignablePublicKey({ bytes });\r\n    }\r\n}\r\nexports.AssignablePublicKey = AssignablePublicKey;\r\nsolanaBorsh_1.SCHEMA.set(AssignablePublicKey, {\r\n    kind: \"struct\",\r\n    fields: [[\"bytes\", [32]]],\r\n});\r\n//# sourceMappingURL=AssignablePublicKey.js.map"]},"metadata":{},"sourceType":"script"}