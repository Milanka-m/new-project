{"ast":null,"code":"import _classCallCheck from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport * as base64 from \"base64-js\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlCoder } from \"./idl\";\nexport var EventCoder = /*#__PURE__*/function () {\n  function EventCoder(idl) {\n    _classCallCheck(this, EventCoder);\n\n    if (idl.events === undefined) {\n      this.layouts = new Map();\n      return;\n    }\n\n    var layouts = idl.events.map(function (event) {\n      var eventTypeDef = {\n        name: event.name,\n        type: {\n          kind: \"struct\",\n          fields: event.fields.map(function (f) {\n            return {\n              name: f.name,\n              type: f.type\n            };\n          })\n        }\n      };\n      return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];\n    }); // @ts-ignore\n\n    this.layouts = new Map(layouts);\n    this.discriminators = new Map(idl.events === undefined ? [] : idl.events.map(function (e) {\n      return [base64.fromByteArray(eventDiscriminator(e.name)), e.name];\n    }));\n  }\n\n  _createClass(EventCoder, [{\n    key: \"decode\",\n    value: function decode(log) {\n      var logArr; // This will throw if log length is not a multiple of 4.\n\n      try {\n        logArr = Buffer.from(base64.toByteArray(log));\n      } catch (e) {\n        return null;\n      }\n\n      var disc = base64.fromByteArray(logArr.slice(0, 8)); // Only deserialize if the discriminator implies a proper event.\n\n      var eventName = this.discriminators.get(disc);\n\n      if (eventName === undefined) {\n        return null;\n      }\n\n      var layout = this.layouts.get(eventName);\n      var data = layout.decode(logArr.slice(8));\n      return {\n        data: data,\n        name: eventName\n      };\n    }\n  }]);\n\n  return EventCoder;\n}();\nexport function eventDiscriminator(name) {\n  return Buffer.from(sha256.digest(\"event:\".concat(name))).slice(0, 8);\n}","map":{"version":3,"sources":["../../../src/coder/event.ts"],"names":[],"mappings":";;AAAA,OAAO,KAAK,MAAZ,MAAwB,WAAxB;AAEA,SAAS,MAAT,QAAuB,WAAvB;AAGA,SAAS,QAAT,QAAyB,OAAzB;AAEA,WAAa,UAAb;AAWE,sBAAmB,GAAnB,EAA2B;AAAA;;AACzB,QAAI,GAAG,CAAC,MAAJ,KAAe,SAAnB,EAA8B;AAC5B,WAAK,OAAL,GAAe,IAAI,GAAJ,EAAf;AACA;AACD;;AACD,QAAM,OAAO,GAAG,GAAG,CAAC,MAAJ,CAAW,GAAX,CAAe,UAAC,KAAD,EAAU;AACvC,UAAI,YAAY,GAAe;AAC7B,QAAA,IAAI,EAAE,KAAK,CAAC,IADiB;AAE7B,QAAA,IAAI,EAAE;AACJ,UAAA,IAAI,EAAE,QADF;AAEJ,UAAA,MAAM,EAAE,KAAK,CAAC,MAAN,CAAa,GAAb,CAAiB,UAAC,CAAD,EAAM;AAC7B,mBAAO;AAAE,cAAA,IAAI,EAAE,CAAC,CAAC,IAAV;AAAgB,cAAA,IAAI,EAAE,CAAC,CAAC;AAAxB,aAAP;AACD,WAFO;AAFJ;AAFuB,OAA/B;AASA,aAAO,CAAC,KAAK,CAAC,IAAP,EAAa,QAAQ,CAAC,aAAT,CAAuB,YAAvB,EAAqC,GAAG,CAAC,KAAzC,CAAb,CAAP;AACD,KAXe,CAAhB,CALyB,CAiBzB;;AACA,SAAK,OAAL,GAAe,IAAI,GAAJ,CAAQ,OAAR,CAAf;AAEA,SAAK,cAAL,GAAsB,IAAI,GAAJ,CACpB,GAAG,CAAC,MAAJ,KAAe,SAAf,GACI,EADJ,GAEI,GAAG,CAAC,MAAJ,CAAW,GAAX,CAAe,UAAC,CAAD;AAAA,aAAO,CACpB,MAAM,CAAC,aAAP,CAAqB,kBAAkB,CAAC,CAAC,CAAC,IAAH,CAAvC,CADoB,EAEpB,CAAC,CAAC,IAFkB,CAAP;AAAA,KAAf,CAHgB,CAAtB;AAQD;;AAvCH;AAAA;AAAA,WAyCS,gBAAO,GAAP,EAAkB;AACvB,UAAI,MAAJ,CADuB,CAEvB;;AACA,UAAI;AACF,QAAA,MAAM,GAAG,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,WAAP,CAAmB,GAAnB,CAAZ,CAAT;AACD,OAFD,CAEE,OAAO,CAAP,EAAU;AACV,eAAO,IAAP;AACD;;AACD,UAAM,IAAI,GAAG,MAAM,CAAC,aAAP,CAAqB,MAAM,CAAC,KAAP,CAAa,CAAb,EAAgB,CAAhB,CAArB,CAAb,CARuB,CAUvB;;AACA,UAAM,SAAS,GAAG,KAAK,cAAL,CAAoB,GAApB,CAAwB,IAAxB,CAAlB;;AACA,UAAI,SAAS,KAAK,SAAlB,EAA6B;AAC3B,eAAO,IAAP;AACD;;AAED,UAAM,MAAM,GAAG,KAAK,OAAL,CAAa,GAAb,CAAiB,SAAjB,CAAf;AACA,UAAM,IAAI,GAAG,MAAM,CAAC,MAAP,CAAc,MAAM,CAAC,KAAP,CAAa,CAAb,CAAd,CAAb;AACA,aAAO;AAAE,QAAA,IAAI,EAAJ,IAAF;AAAQ,QAAA,IAAI,EAAE;AAAd,OAAP;AACD;AA5DH;;AAAA;AAAA;AA+DA,OAAM,SAAU,kBAAV,CAA6B,IAA7B,EAAyC;AAC7C,SAAO,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,MAAP,iBAAuB,IAAvB,EAAZ,EAA4C,KAA5C,CAAkD,CAAlD,EAAqD,CAArD,CAAP;AACD","sourceRoot":"","sourcesContent":["import * as base64 from \"base64-js\";\r\nimport { sha256 } from \"js-sha256\";\r\nimport { IdlCoder } from \"./idl\";\r\nexport class EventCoder {\r\n    constructor(idl) {\r\n        if (idl.events === undefined) {\r\n            this.layouts = new Map();\r\n            return;\r\n        }\r\n        const layouts = idl.events.map((event) => {\r\n            let eventTypeDef = {\r\n                name: event.name,\r\n                type: {\r\n                    kind: \"struct\",\r\n                    fields: event.fields.map((f) => {\r\n                        return { name: f.name, type: f.type };\r\n                    }),\r\n                },\r\n            };\r\n            return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];\r\n        });\r\n        // @ts-ignore\r\n        this.layouts = new Map(layouts);\r\n        this.discriminators = new Map(idl.events === undefined\r\n            ? []\r\n            : idl.events.map((e) => [\r\n                base64.fromByteArray(eventDiscriminator(e.name)),\r\n                e.name,\r\n            ]));\r\n    }\r\n    decode(log) {\r\n        let logArr;\r\n        // This will throw if log length is not a multiple of 4.\r\n        try {\r\n            logArr = Buffer.from(base64.toByteArray(log));\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n        const disc = base64.fromByteArray(logArr.slice(0, 8));\r\n        // Only deserialize if the discriminator implies a proper event.\r\n        const eventName = this.discriminators.get(disc);\r\n        if (eventName === undefined) {\r\n            return null;\r\n        }\r\n        const layout = this.layouts.get(eventName);\r\n        const data = layout.decode(logArr.slice(8));\r\n        return { data, name: eventName };\r\n    }\r\n}\r\nexport function eventDiscriminator(name) {\r\n    return Buffer.from(sha256.digest(`event:${name}`)).slice(0, 8);\r\n}\r\n//# sourceMappingURL=event.js.map"]},"metadata":{},"sourceType":"module"}