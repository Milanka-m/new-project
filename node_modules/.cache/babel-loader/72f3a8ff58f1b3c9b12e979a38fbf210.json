{"ast":null,"code":"import { useEffect } from 'react';\nimport { GatekeeperRecordState, GatewayStatus } from '../types';\nimport logger from '../logger';\nimport useWalletHooks from './useWalletHooks';\nexport const reducer = (state, action) => {\n  switch (action.type) {\n    case 'tokenOnChainNotFound':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: GatewayStatus.NOT_REQUESTED\n      });\n\n    case 'tokenOnChainError':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: GatewayStatus.ERROR\n      });\n\n    default:\n      return state;\n  }\n};\n\nconst useChain = (_ref, state, dispatch) => {\n  let {\n    wallet,\n    chainImplementation\n  } = _ref;\n  const {\n    expectWalletConnected\n  } = useWalletHooks(wallet, state, dispatch);\n  const {\n    gatekeeperRecordState,\n    gatewayToken\n  } = state;\n\n  const logDebug = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger.debug(`[useChain] ${message}`, obj);\n  };\n\n  const logError = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger.error(`[useChain] ${message}`, obj);\n  };\n\n  const removeOnChainListener = listernerId => {\n    try {\n      logDebug('Removing onChainListener with id: ', listernerId);\n      chainImplementation.removeOnGatewayTokenChangeListener(listernerId);\n    } catch (error) {\n      logError('Error removing on chain listener', error);\n    }\n  };\n  /**\r\n   * listen to the blockchain for any token changes and update local state if there are\r\n   */\n\n\n  const addTokenChangeListeners = // eslint-disable-next-line @typescript-eslint/no-shadow\n  gatewayToken => {\n    const tokenChangeCallback = token => {\n      dispatch({\n        type: 'tokenChange',\n        token\n      });\n      dispatch({\n        type: 'civicPass_check_token_status',\n        token\n      });\n    };\n\n    const listernerId = chainImplementation.addOnGatewayTokenChangeListener(gatewayToken, tokenChangeCallback);\n    logDebug('Adding onChainListener with id: ', listernerId);\n    return listernerId;\n  };\n\n  useEffect(() => {\n    let listernerId;\n\n    if (gatewayToken) {\n      listernerId = addTokenChangeListeners(gatewayToken);\n    }\n\n    return () => {\n      if (listernerId) {\n        removeOnChainListener(listernerId);\n      }\n    };\n  }, [gatekeeperRecordState, gatewayToken]);\n  /**\r\n   * use the on-chain lookup utility findGatewayToken to retrieve a token from the chain\r\n   * when a token is found, set up listeners to monitor any on-chain changes\r\n   */\n\n  const dispatchTokenFromChain = async () => {\n    const connectedWallet = expectWalletConnected();\n\n    try {\n      logDebug('Fetching token from chain');\n      const token = await chainImplementation.findGatewayToken();\n\n      if (!token) {\n        dispatch({\n          type: 'tokenOnChainNotFound'\n        });\n        return;\n      }\n\n      logDebug('Token found', token);\n      dispatch({\n        type: 'tokenChange',\n        token\n      }); // Determine if we should show the civicPass dialog when we have a gateway token\n\n      const shouldDispatchTokenFromChain = gatekeeperRecordState && [GatekeeperRecordState.ISSUED_EXPIRED, GatekeeperRecordState.ISSUED_EXPIRY_APPROACHING, GatekeeperRecordState.ISSUED_LOCATION_NOT_SUPPORTED].includes(gatekeeperRecordState);\n      if (!shouldDispatchTokenFromChain) return;\n      dispatch({\n        type: 'civicPass_check_token_status',\n        token\n      });\n    } catch (error) {\n      logError(`Error getting token from chain for ${connectedWallet.publicKey}`, error);\n      dispatch({\n        type: 'tokenOnChainError'\n      });\n      throw error;\n    }\n  };\n  /**\r\n   * Determine if we should fetch a token from chain based on the gatekeeper record state\r\n   */\n\n\n  useEffect(() => {\n    const shouldDispatchTokenFromChain = gatekeeperRecordState && [GatekeeperRecordState.ISSUED, GatekeeperRecordState.ISSUED_EXPIRED, GatekeeperRecordState.ISSUED_EXPIRY_APPROACHING, GatekeeperRecordState.REQUESTED, GatekeeperRecordState.ISSUED_LOCATION_NOT_SUPPORTED, GatekeeperRecordState.SERVER_FAILURE].includes(gatekeeperRecordState);\n    if (!shouldDispatchTokenFromChain) return;\n    dispatchTokenFromChain();\n  }, [gatekeeperRecordState]);\n  return {\n    addTokenChangeListeners,\n    dispatchTokenFromChain\n  };\n};\n\nexport default useChain;","map":{"version":3,"sources":["D:/Lianok/dev/new-project/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useChain.js"],"names":["useEffect","GatekeeperRecordState","GatewayStatus","logger","useWalletHooks","reducer","state","action","type","Object","assign","gatewayStatus","NOT_REQUESTED","ERROR","useChain","dispatch","wallet","chainImplementation","expectWalletConnected","gatekeeperRecordState","gatewayToken","logDebug","message","obj","debug","logError","error","removeOnChainListener","listernerId","removeOnGatewayTokenChangeListener","addTokenChangeListeners","tokenChangeCallback","token","addOnGatewayTokenChangeListener","dispatchTokenFromChain","connectedWallet","findGatewayToken","shouldDispatchTokenFromChain","ISSUED_EXPIRED","ISSUED_EXPIRY_APPROACHING","ISSUED_LOCATION_NOT_SUPPORTED","includes","publicKey","ISSUED","REQUESTED","SERVER_FAILURE"],"mappings":"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","sourcesContent":["import { useEffect } from 'react';\r\nimport { GatekeeperRecordState, GatewayStatus } from '../types';\r\nimport logger from '../logger';\r\nimport useWalletHooks from './useWalletHooks';\r\nexport const reducer = (state, action) => {\r\n    switch (action.type) {\r\n        case 'tokenOnChainNotFound':\r\n            return Object.assign(Object.assign({}, state), { gatewayStatus: GatewayStatus.NOT_REQUESTED });\r\n        case 'tokenOnChainError':\r\n            return Object.assign(Object.assign({}, state), { gatewayStatus: GatewayStatus.ERROR });\r\n        default:\r\n            return state;\r\n    }\r\n};\r\nconst useChain = ({ wallet, chainImplementation, }, state, dispatch) => {\r\n    const { expectWalletConnected } = useWalletHooks(wallet, state, dispatch);\r\n    const { gatekeeperRecordState, gatewayToken } = state;\r\n    const logDebug = (message, obj = null) => logger.debug(`[useChain] ${message}`, obj);\r\n    const logError = (message, obj = null) => logger.error(`[useChain] ${message}`, obj);\r\n    const removeOnChainListener = (listernerId) => {\r\n        try {\r\n            logDebug('Removing onChainListener with id: ', listernerId);\r\n            chainImplementation.removeOnGatewayTokenChangeListener(listernerId);\r\n        }\r\n        catch (error) {\r\n            logError('Error removing on chain listener', error);\r\n        }\r\n    };\r\n    /**\r\n     * listen to the blockchain for any token changes and update local state if there are\r\n     */\r\n    const addTokenChangeListeners = \r\n    // eslint-disable-next-line @typescript-eslint/no-shadow\r\n    (gatewayToken) => {\r\n        const tokenChangeCallback = (token) => {\r\n            dispatch({ type: 'tokenChange', token });\r\n            dispatch({ type: 'civicPass_check_token_status', token });\r\n        };\r\n        const listernerId = chainImplementation.addOnGatewayTokenChangeListener(gatewayToken, tokenChangeCallback);\r\n        logDebug('Adding onChainListener with id: ', listernerId);\r\n        return listernerId;\r\n    };\r\n    useEffect(() => {\r\n        let listernerId;\r\n        if (gatewayToken) {\r\n            listernerId = addTokenChangeListeners(gatewayToken);\r\n        }\r\n        return () => {\r\n            if (listernerId) {\r\n                removeOnChainListener(listernerId);\r\n            }\r\n        };\r\n    }, [gatekeeperRecordState, gatewayToken]);\r\n    /**\r\n     * use the on-chain lookup utility findGatewayToken to retrieve a token from the chain\r\n     * when a token is found, set up listeners to monitor any on-chain changes\r\n     */\r\n    const dispatchTokenFromChain = async () => {\r\n        const connectedWallet = expectWalletConnected();\r\n        try {\r\n            logDebug('Fetching token from chain');\r\n            const token = await chainImplementation.findGatewayToken();\r\n            if (!token) {\r\n                dispatch({ type: 'tokenOnChainNotFound' });\r\n                return;\r\n            }\r\n            logDebug('Token found', token);\r\n            dispatch({ type: 'tokenChange', token });\r\n            // Determine if we should show the civicPass dialog when we have a gateway token\r\n            const shouldDispatchTokenFromChain = gatekeeperRecordState &&\r\n                [\r\n                    GatekeeperRecordState.ISSUED_EXPIRED,\r\n                    GatekeeperRecordState.ISSUED_EXPIRY_APPROACHING,\r\n                    GatekeeperRecordState.ISSUED_LOCATION_NOT_SUPPORTED,\r\n                ].includes(gatekeeperRecordState);\r\n            if (!shouldDispatchTokenFromChain)\r\n                return;\r\n            dispatch({ type: 'civicPass_check_token_status', token });\r\n        }\r\n        catch (error) {\r\n            logError(`Error getting token from chain for ${connectedWallet.publicKey}`, error);\r\n            dispatch({ type: 'tokenOnChainError' });\r\n            throw error;\r\n        }\r\n    };\r\n    /**\r\n     * Determine if we should fetch a token from chain based on the gatekeeper record state\r\n     */\r\n    useEffect(() => {\r\n        const shouldDispatchTokenFromChain = gatekeeperRecordState &&\r\n            [\r\n                GatekeeperRecordState.ISSUED,\r\n                GatekeeperRecordState.ISSUED_EXPIRED,\r\n                GatekeeperRecordState.ISSUED_EXPIRY_APPROACHING,\r\n                GatekeeperRecordState.REQUESTED,\r\n                GatekeeperRecordState.ISSUED_LOCATION_NOT_SUPPORTED,\r\n                GatekeeperRecordState.SERVER_FAILURE,\r\n            ].includes(gatekeeperRecordState);\r\n        if (!shouldDispatchTokenFromChain)\r\n            return;\r\n        dispatchTokenFromChain();\r\n    }, [gatekeeperRecordState]);\r\n    return {\r\n        addTokenChangeListeners,\r\n        dispatchTokenFromChain,\r\n    };\r\n};\r\nexport default useChain;\r\n"]},"metadata":{},"sourceType":"module"}