{"ast":null,"code":"import _asyncToGenerator from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _classCallCheck from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport { Connection, Keypair, sendAndConfirmRawTransaction } from \"@solana/web3.js\";\nimport { isBrowser } from \"./utils/common\";\n/**\r\n * The network and wallet context used to send transactions paid for and signed\r\n * by the provider.\r\n */\n\nvar Provider = /*#__PURE__*/function () {\n  /**\r\n   * @param connection The cluster connection where the program is deployed.\r\n   * @param wallet     The wallet used to pay for and sign all transactions.\r\n   * @param opts       Transaction confirmation options to use by default.\r\n   */\n  function Provider(connection, wallet, opts) {\n    _classCallCheck(this, Provider);\n\n    this.connection = connection;\n    this.wallet = wallet;\n    this.opts = opts;\n  }\n\n  _createClass(Provider, [{\n    key: \"send\",\n    value:\n    /**\r\n     * Sends the given transaction, paid for and signed by the provider's wallet.\r\n     *\r\n     * @param tx      The transaction to send.\r\n     * @param signers The set of signers in addition to the provdier wallet that\r\n     *                will sign the transaction.\r\n     * @param opts    Transaction confirmation options.\r\n     */\n    function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tx, signers, opts) {\n        var rawTx, txId;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (signers === undefined) {\n                  signers = [];\n                }\n\n                if (opts === undefined) {\n                  opts = this.opts;\n                }\n\n                tx.feePayer = this.wallet.publicKey;\n                _context.next = 5;\n                return this.connection.getRecentBlockhash(opts.preflightCommitment);\n\n              case 5:\n                tx.recentBlockhash = _context.sent.blockhash;\n                _context.next = 8;\n                return this.wallet.signTransaction(tx);\n\n              case 8:\n                signers.filter(function (s) {\n                  return s !== undefined;\n                }).forEach(function (kp) {\n                  tx.partialSign(kp);\n                });\n                rawTx = tx.serialize();\n                _context.next = 12;\n                return sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n\n              case 12:\n                txId = _context.sent;\n                return _context.abrupt(\"return\", txId);\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function send(_x, _x2, _x3) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n    /**\r\n     * Similar to `send`, but for an array of transactions and signers.\r\n     */\n\n  }, {\n    key: \"sendAll\",\n    value: function () {\n      var _sendAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(reqs, opts) {\n        var _this = this;\n\n        var blockhash, txs, signedTxs, sigs, k, tx, rawTx;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (opts === undefined) {\n                  opts = this.opts;\n                }\n\n                _context2.next = 3;\n                return this.connection.getRecentBlockhash(opts.preflightCommitment);\n\n              case 3:\n                blockhash = _context2.sent;\n                txs = reqs.map(function (r) {\n                  var tx = r.tx;\n                  var signers = r.signers;\n\n                  if (signers === undefined) {\n                    signers = [];\n                  }\n\n                  tx.feePayer = _this.wallet.publicKey;\n                  tx.recentBlockhash = blockhash.blockhash;\n                  signers.filter(function (s) {\n                    return s !== undefined;\n                  }).forEach(function (kp) {\n                    tx.partialSign(kp);\n                  });\n                  return tx;\n                });\n                _context2.next = 7;\n                return this.wallet.signAllTransactions(txs);\n\n              case 7:\n                signedTxs = _context2.sent;\n                sigs = [];\n                k = 0;\n\n              case 10:\n                if (!(k < txs.length)) {\n                  _context2.next = 21;\n                  break;\n                }\n\n                tx = signedTxs[k];\n                rawTx = tx.serialize();\n                _context2.t0 = sigs;\n                _context2.next = 16;\n                return sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n\n              case 16:\n                _context2.t1 = _context2.sent;\n\n                _context2.t0.push.call(_context2.t0, _context2.t1);\n\n              case 18:\n                k += 1;\n                _context2.next = 10;\n                break;\n\n              case 21:\n                return _context2.abrupt(\"return\", sigs);\n\n              case 22:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function sendAll(_x4, _x5) {\n        return _sendAll.apply(this, arguments);\n      }\n\n      return sendAll;\n    }()\n    /**\r\n     * Simulates the given transaction, returning emitted logs from execution.\r\n     *\r\n     * @param tx      The transaction to send.\r\n     * @param signers The set of signers in addition to the provdier wallet that\r\n     *                will sign the transaction.\r\n     * @param opts    Transaction confirmation options.\r\n     */\n\n  }, {\n    key: \"simulate\",\n    value: function () {\n      var _simulate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(tx, signers, opts) {\n        var _a, _b;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (signers === undefined) {\n                  signers = [];\n                }\n\n                if (opts === undefined) {\n                  opts = this.opts;\n                }\n\n                tx.feePayer = this.wallet.publicKey;\n                _context3.next = 5;\n                return this.connection.getRecentBlockhash((_a = opts.preflightCommitment) !== null && _a !== void 0 ? _a : this.opts.preflightCommitment);\n\n              case 5:\n                tx.recentBlockhash = _context3.sent.blockhash;\n                _context3.next = 8;\n                return this.wallet.signTransaction(tx);\n\n              case 8:\n                signers.filter(function (s) {\n                  return s !== undefined;\n                }).forEach(function (kp) {\n                  tx.partialSign(kp);\n                });\n                _context3.next = 11;\n                return simulateTransaction(this.connection, tx, (_b = opts.commitment) !== null && _b !== void 0 ? _b : this.opts.commitment);\n\n              case 11:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 12:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function simulate(_x6, _x7, _x8) {\n        return _simulate.apply(this, arguments);\n      }\n\n      return simulate;\n    }()\n  }], [{\n    key: \"defaultOptions\",\n    value: function defaultOptions() {\n      return {\n        preflightCommitment: \"recent\",\n        commitment: \"recent\"\n      };\n    }\n    /**\r\n     * Returns a `Provider` with a wallet read from the local filesystem.\r\n     *\r\n     * @param url  The network cluster url.\r\n     * @param opts The default transaction confirmation options.\r\n     *\r\n     * (This api is for Node only.)\r\n     */\n\n  }, {\n    key: \"local\",\n    value: function local(url, opts) {\n      opts = opts !== null && opts !== void 0 ? opts : Provider.defaultOptions();\n      var connection = new Connection(url !== null && url !== void 0 ? url : \"http://localhost:8899\", opts.preflightCommitment);\n      var wallet = NodeWallet.local();\n      return new Provider(connection, wallet, opts);\n    }\n    /**\r\n     * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\r\n     * variable\r\n     *\r\n     * (This api is for Node only.)\r\n     */\n\n  }, {\n    key: \"env\",\n    value: function env() {\n      if (isBrowser) return;\n\n      var process = require(\"process\");\n\n      var url = process.env.ANCHOR_PROVIDER_URL;\n\n      if (url === undefined) {\n        throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\n      }\n\n      var options = Provider.defaultOptions();\n      var connection = new Connection(url, options.commitment);\n      var wallet = NodeWallet.local();\n      return new Provider(connection, wallet, options);\n    }\n  }]);\n\n  return Provider;\n}();\n/**\r\n * Node only wallet.\r\n */\n\n\nexport { Provider as default };\nexport var NodeWallet = /*#__PURE__*/function () {\n  function NodeWallet(payer) {\n    _classCallCheck(this, NodeWallet);\n\n    this.payer = payer;\n  }\n\n  _createClass(NodeWallet, [{\n    key: \"signTransaction\",\n    value: function () {\n      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(tx) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                tx.partialSign(this.payer);\n                return _context4.abrupt(\"return\", tx);\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function signTransaction(_x9) {\n        return _signTransaction.apply(this, arguments);\n      }\n\n      return signTransaction;\n    }()\n  }, {\n    key: \"signAllTransactions\",\n    value: function () {\n      var _signAllTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(txs) {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", txs.map(function (t) {\n                  t.partialSign(_this2.payer);\n                  return t;\n                }));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function signAllTransactions(_x10) {\n        return _signAllTransactions.apply(this, arguments);\n      }\n\n      return signAllTransactions;\n    }()\n  }, {\n    key: \"publicKey\",\n    get: function get() {\n      return this.payer.publicKey;\n    }\n  }], [{\n    key: \"local\",\n    value: function local() {\n      var payer = Keypair.fromSecretKey(Buffer.from(JSON.parse(require(\"fs\").readFileSync(require(\"os\").homedir() + \"/.config/solana/id.json\", {\n        encoding: \"utf-8\"\n      }))));\n      return new NodeWallet(payer);\n    }\n  }]);\n\n  return NodeWallet;\n}(); // Copy of Connection.simulateTransaction that takes a commitment parameter.\n\nfunction simulateTransaction(_x11, _x12, _x13) {\n  return _simulateTransaction.apply(this, arguments);\n}\n/**\r\n * Sets the default provider on the client.\r\n */\n\n\nfunction _simulateTransaction() {\n  _simulateTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(connection, transaction, commitment) {\n    var signData, wireTransaction, encodedTransaction, config, args, res;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return connection._recentBlockhash( // @ts-ignore\n            connection._disableBlockhashCaching);\n\n          case 2:\n            transaction.recentBlockhash = _context6.sent;\n            signData = transaction.serializeMessage(); // @ts-ignore\n\n            wireTransaction = transaction._serialize(signData);\n            encodedTransaction = wireTransaction.toString(\"base64\");\n            config = {\n              encoding: \"base64\",\n              commitment: commitment\n            };\n            args = [encodedTransaction, config]; // @ts-ignore\n\n            _context6.next = 10;\n            return connection._rpcRequest(\"simulateTransaction\", args);\n\n          case 10:\n            res = _context6.sent;\n\n            if (!res.error) {\n              _context6.next = 13;\n              break;\n            }\n\n            throw new Error(\"failed to simulate transaction: \" + res.error.message);\n\n          case 13:\n            return _context6.abrupt(\"return\", res.result);\n\n          case 14:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _simulateTransaction.apply(this, arguments);\n}\n\nexport function setProvider(provider) {\n  _provider = provider;\n}\n/**\r\n * Returns the default provider being used by the client.\r\n */\n\nexport function getProvider() {\n  if (_provider === null) {\n    return Provider.local();\n  }\n\n  return _provider;\n} // Global provider used as the default when a provider is not given.\n\nvar _provider = null;","map":{"version":3,"sources":["../../src/provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Connection, Keypair, sendAndConfirmRawTransaction, } from \"@solana/web3.js\";\r\nimport { isBrowser } from \"./utils/common\";\r\n/**\r\n * The network and wallet context used to send transactions paid for and signed\r\n * by the provider.\r\n */\r\nexport default class Provider {\r\n    /**\r\n     * @param connection The cluster connection where the program is deployed.\r\n     * @param wallet     The wallet used to pay for and sign all transactions.\r\n     * @param opts       Transaction confirmation options to use by default.\r\n     */\r\n    constructor(connection, wallet, opts) {\r\n        this.connection = connection;\r\n        this.wallet = wallet;\r\n        this.opts = opts;\r\n    }\r\n    static defaultOptions() {\r\n        return {\r\n            preflightCommitment: \"recent\",\r\n            commitment: \"recent\",\r\n        };\r\n    }\r\n    /**\r\n     * Returns a `Provider` with a wallet read from the local filesystem.\r\n     *\r\n     * @param url  The network cluster url.\r\n     * @param opts The default transaction confirmation options.\r\n     *\r\n     * (This api is for Node only.)\r\n     */\r\n    static local(url, opts) {\r\n        opts = opts !== null && opts !== void 0 ? opts : Provider.defaultOptions();\r\n        const connection = new Connection(url !== null && url !== void 0 ? url : \"http://localhost:8899\", opts.preflightCommitment);\r\n        const wallet = NodeWallet.local();\r\n        return new Provider(connection, wallet, opts);\r\n    }\r\n    /**\r\n     * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\r\n     * variable\r\n     *\r\n     * (This api is for Node only.)\r\n     */\r\n    static env() {\r\n        if (isBrowser)\r\n            return;\r\n        const process = require(\"process\");\r\n        const url = process.env.ANCHOR_PROVIDER_URL;\r\n        if (url === undefined) {\r\n            throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\r\n        }\r\n        const options = Provider.defaultOptions();\r\n        const connection = new Connection(url, options.commitment);\r\n        const wallet = NodeWallet.local();\r\n        return new Provider(connection, wallet, options);\r\n    }\r\n    /**\r\n     * Sends the given transaction, paid for and signed by the provider's wallet.\r\n     *\r\n     * @param tx      The transaction to send.\r\n     * @param signers The set of signers in addition to the provdier wallet that\r\n     *                will sign the transaction.\r\n     * @param opts    Transaction confirmation options.\r\n     */\r\n    async send(tx, signers, opts) {\r\n        if (signers === undefined) {\r\n            signers = [];\r\n        }\r\n        if (opts === undefined) {\r\n            opts = this.opts;\r\n        }\r\n        tx.feePayer = this.wallet.publicKey;\r\n        tx.recentBlockhash = (await this.connection.getRecentBlockhash(opts.preflightCommitment)).blockhash;\r\n        await this.wallet.signTransaction(tx);\r\n        signers\r\n            .filter((s) => s !== undefined)\r\n            .forEach((kp) => {\r\n            tx.partialSign(kp);\r\n        });\r\n        const rawTx = tx.serialize();\r\n        const txId = await sendAndConfirmRawTransaction(this.connection, rawTx, opts);\r\n        return txId;\r\n    }\r\n    /**\r\n     * Similar to `send`, but for an array of transactions and signers.\r\n     */\r\n    async sendAll(reqs, opts) {\r\n        if (opts === undefined) {\r\n            opts = this.opts;\r\n        }\r\n        const blockhash = await this.connection.getRecentBlockhash(opts.preflightCommitment);\r\n        let txs = reqs.map((r) => {\r\n            let tx = r.tx;\r\n            let signers = r.signers;\r\n            if (signers === undefined) {\r\n                signers = [];\r\n            }\r\n            tx.feePayer = this.wallet.publicKey;\r\n            tx.recentBlockhash = blockhash.blockhash;\r\n            signers\r\n                .filter((s) => s !== undefined)\r\n                .forEach((kp) => {\r\n                tx.partialSign(kp);\r\n            });\r\n            return tx;\r\n        });\r\n        const signedTxs = await this.wallet.signAllTransactions(txs);\r\n        const sigs = [];\r\n        for (let k = 0; k < txs.length; k += 1) {\r\n            const tx = signedTxs[k];\r\n            const rawTx = tx.serialize();\r\n            sigs.push(await sendAndConfirmRawTransaction(this.connection, rawTx, opts));\r\n        }\r\n        return sigs;\r\n    }\r\n    /**\r\n     * Simulates the given transaction, returning emitted logs from execution.\r\n     *\r\n     * @param tx      The transaction to send.\r\n     * @param signers The set of signers in addition to the provdier wallet that\r\n     *                will sign the transaction.\r\n     * @param opts    Transaction confirmation options.\r\n     */\r\n    async simulate(tx, signers, opts) {\r\n        var _a, _b;\r\n        if (signers === undefined) {\r\n            signers = [];\r\n        }\r\n        if (opts === undefined) {\r\n            opts = this.opts;\r\n        }\r\n        tx.feePayer = this.wallet.publicKey;\r\n        tx.recentBlockhash = (await this.connection.getRecentBlockhash((_a = opts.preflightCommitment) !== null && _a !== void 0 ? _a : this.opts.preflightCommitment)).blockhash;\r\n        await this.wallet.signTransaction(tx);\r\n        signers\r\n            .filter((s) => s !== undefined)\r\n            .forEach((kp) => {\r\n            tx.partialSign(kp);\r\n        });\r\n        return await simulateTransaction(this.connection, tx, (_b = opts.commitment) !== null && _b !== void 0 ? _b : this.opts.commitment);\r\n    }\r\n}\r\n/**\r\n * Node only wallet.\r\n */\r\nexport class NodeWallet {\r\n    constructor(payer) {\r\n        this.payer = payer;\r\n    }\r\n    static local() {\r\n        const payer = Keypair.fromSecretKey(Buffer.from(JSON.parse(require(\"fs\").readFileSync(require(\"os\").homedir() + \"/.config/solana/id.json\", {\r\n            encoding: \"utf-8\",\r\n        }))));\r\n        return new NodeWallet(payer);\r\n    }\r\n    async signTransaction(tx) {\r\n        tx.partialSign(this.payer);\r\n        return tx;\r\n    }\r\n    async signAllTransactions(txs) {\r\n        return txs.map((t) => {\r\n            t.partialSign(this.payer);\r\n            return t;\r\n        });\r\n    }\r\n    get publicKey() {\r\n        return this.payer.publicKey;\r\n    }\r\n}\r\n// Copy of Connection.simulateTransaction that takes a commitment parameter.\r\nasync function simulateTransaction(connection, transaction, commitment) {\r\n    // @ts-ignore\r\n    transaction.recentBlockhash = await connection._recentBlockhash(\r\n    // @ts-ignore\r\n    connection._disableBlockhashCaching);\r\n    const signData = transaction.serializeMessage();\r\n    // @ts-ignore\r\n    const wireTransaction = transaction._serialize(signData);\r\n    const encodedTransaction = wireTransaction.toString(\"base64\");\r\n    const config = { encoding: \"base64\", commitment };\r\n    const args = [encodedTransaction, config];\r\n    // @ts-ignore\r\n    const res = await connection._rpcRequest(\"simulateTransaction\", args);\r\n    if (res.error) {\r\n        throw new Error(\"failed to simulate transaction: \" + res.error.message);\r\n    }\r\n    return res.result;\r\n}\r\n/**\r\n * Sets the default provider on the client.\r\n */\r\nexport function setProvider(provider) {\r\n    _provider = provider;\r\n}\r\n/**\r\n * Returns the default provider being used by the client.\r\n */\r\nexport function getProvider() {\r\n    if (_provider === null) {\r\n        return Provider.local();\r\n    }\r\n    return _provider;\r\n}\r\n// Global provider used as the default when a provider is not given.\r\nlet _provider = null;\r\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}