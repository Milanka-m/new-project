{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Enum = exports.Assignable = exports.SCHEMA = void 0;\n\nconst borsh_1 = require(\"borsh\");\n\nexports.SCHEMA = new Map(); // Class wrapping a plain object\n\nclass Assignable {\n  constructor(properties) {\n    Object.keys(properties).forEach(key => {\n      // this is probably possible in Typescript,\n      // but requires (keyof this) which is not possible in the the constructor\n      // @ts-ignore\n      this[key] = properties[key];\n    });\n  }\n\n  encode() {\n    return Buffer.from((0, borsh_1.serialize)(exports.SCHEMA, this));\n  }\n\n  static decode(data) {\n    return (0, borsh_1.deserialize)(exports.SCHEMA, this, data);\n  }\n\n}\n\nexports.Assignable = Assignable; // Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\n\nclass Enum extends Assignable {\n  constructor(properties) {\n    super(properties);\n\n    if (Object.keys(properties).length !== 1) {\n      throw new Error(\"Enum can only take single value\");\n    }\n\n    this.enum = \"\";\n    Object.keys(properties).forEach(key => {\n      this.enum = key;\n    });\n  }\n\n}\n\nexports.Enum = Enum;","map":{"version":3,"sources":["../../src/lib/solanaBorsh.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AAEa,OAAA,CAAA,MAAA,GAAiB,IAAI,GAAJ,EAAjB,C,CAEb;;AACA,MAAsB,UAAtB,CAAgC;AAC9B,EAAA,WAAA,CAAY,UAAZ,EAA8C;AAC5C,IAAA,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAwB,OAAxB,CAAiC,GAAD,IAAgB;AAC9C;AACA;AACA;AACA,WAAK,GAAL,IAAY,UAAU,CAAC,GAAD,CAAtB;AACD,KALD;AAMD;;AAED,EAAA,MAAM,GAAA;AACJ,WAAO,MAAM,CAAC,IAAP,CAAY,CAAA,GAAA,OAAA,CAAA,SAAA,EAAU,OAAA,CAAA,MAAV,EAAkB,IAAlB,CAAZ,CAAP;AACD;;AAEY,SAAN,MAAM,CAAuB,IAAvB,EAAmC;AAC9C,WAAO,CAAA,GAAA,OAAA,CAAA,WAAA,EAAY,OAAA,CAAA,MAAZ,EAAoB,IAApB,EAA0B,IAA1B,CAAP;AACD;;AAhB6B;;AAAhC,OAAA,CAAA,UAAA,GAAA,UAAA,C,CAmBA;AACA;;AACA,MAAsB,IAAtB,SAAmC,UAAnC,CAA6C;AAG3C,EAAA,WAAA,CAAY,UAAZ,EAA2B;AACzB,UAAM,UAAN;;AACA,QAAI,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAwB,MAAxB,KAAmC,CAAvC,EAA0C;AACxC,YAAM,IAAI,KAAJ,CAAU,iCAAV,CAAN;AACD;;AACD,SAAK,IAAL,GAAY,EAAZ;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAwB,OAAxB,CAAiC,GAAD,IAAQ;AACtC,WAAK,IAAL,GAAY,GAAZ;AACD,KAFD;AAGD;;AAZ0C;;AAA7C,OAAA,CAAA,IAAA,GAAA,IAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Enum = exports.Assignable = exports.SCHEMA = void 0;\r\nconst borsh_1 = require(\"borsh\");\r\nexports.SCHEMA = new Map();\r\n// Class wrapping a plain object\r\nclass Assignable {\r\n    constructor(properties) {\r\n        Object.keys(properties).forEach((key) => {\r\n            // this is probably possible in Typescript,\r\n            // but requires (keyof this) which is not possible in the the constructor\r\n            // @ts-ignore\r\n            this[key] = properties[key];\r\n        });\r\n    }\r\n    encode() {\r\n        return Buffer.from((0, borsh_1.serialize)(exports.SCHEMA, this));\r\n    }\r\n    static decode(data) {\r\n        return (0, borsh_1.deserialize)(exports.SCHEMA, this, data);\r\n    }\r\n}\r\nexports.Assignable = Assignable;\r\n// Class representing a Rust-compatible enum, since enums are only strings or\r\n// numbers in pure JS\r\nclass Enum extends Assignable {\r\n    constructor(properties) {\r\n        super(properties);\r\n        if (Object.keys(properties).length !== 1) {\r\n            throw new Error(\"Enum can only take single value\");\r\n        }\r\n        this.enum = \"\";\r\n        Object.keys(properties).forEach((key) => {\r\n            this.enum = key;\r\n        });\r\n    }\r\n}\r\nexports.Enum = Enum;\r\n//# sourceMappingURL=solanaBorsh.js.map"]},"metadata":{},"sourceType":"script"}