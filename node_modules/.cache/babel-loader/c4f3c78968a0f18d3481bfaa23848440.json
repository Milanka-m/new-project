{"ast":null,"code":"import _curry2 from \"./internal/_curry2.js\";\n/**\r\n * Takes a list and returns a list of lists where each sublist's elements are\r\n * all satisfied pairwise comparison according to the provided function.\r\n * Only adjacent elements are passed to the comparison function.\r\n *\r\n * @func\r\n * @memberOf R\r\n * @since v0.21.0\r\n * @category List\r\n * @sig ((a, a) → Boolean) → [a] → [[a]]\r\n * @param {Function} fn Function for determining whether two given (adjacent)\r\n *        elements should be in the same group\r\n * @param {Array} list The array to group. Also accepts a string, which will be\r\n *        treated as a list of characters.\r\n * @return {List} A list that contains sublists of elements,\r\n *         whose concatenations are equal to the original list.\r\n * @example\r\n *\r\n * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])\r\n * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]\r\n *\r\n * R.groupWith((a, b) => a + 1 === b, [0, 1, 1, 2, 3, 5, 8, 13, 21])\r\n * //=> [[0, 1], [1, 2, 3], [5], [8], [13], [21]]\r\n *\r\n * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])\r\n * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]\r\n *\r\n * R.groupWith(R.eqBy(isVowel), 'aestiou')\r\n * //=> ['ae', 'st', 'iou']\r\n */\n\nvar groupWith = /*#__PURE__*/_curry2(function (fn, list) {\n  var res = [];\n  var idx = 0;\n  var len = list.length;\n\n  while (idx < len) {\n    var nextidx = idx + 1;\n\n    while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {\n      nextidx += 1;\n    }\n\n    res.push(list.slice(idx, nextidx));\n    idx = nextidx;\n  }\n\n  return res;\n});\n\nexport default groupWith;","map":{"version":3,"sources":["D:/Lianok/dev/new-project/node_modules/ramda/es/groupWith.js"],"names":["_curry2","groupWith","fn","list","res","idx","len","length","nextidx","push","slice"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,uBAApB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,SAAS,GACb,aACAD,OAAO,CAAC,UAAUE,EAAV,EAAcC,IAAd,EAAoB;AAC1B,MAAIC,GAAG,GAAG,EAAV;AACA,MAAIC,GAAG,GAAG,CAAV;AACA,MAAIC,GAAG,GAAGH,IAAI,CAACI,MAAf;;AAEA,SAAOF,GAAG,GAAGC,GAAb,EAAkB;AAChB,QAAIE,OAAO,GAAGH,GAAG,GAAG,CAApB;;AAEA,WAAOG,OAAO,GAAGF,GAAV,IAAiBJ,EAAE,CAACC,IAAI,CAACK,OAAO,GAAG,CAAX,CAAL,EAAoBL,IAAI,CAACK,OAAD,CAAxB,CAA1B,EAA8D;AAC5DA,MAAAA,OAAO,IAAI,CAAX;AACD;;AAEDJ,IAAAA,GAAG,CAACK,IAAJ,CAASN,IAAI,CAACO,KAAL,CAAWL,GAAX,EAAgBG,OAAhB,CAAT;AACAH,IAAAA,GAAG,GAAGG,OAAN;AACD;;AAED,SAAOJ,GAAP;AACD,CAjBM,CAFP;;AAqBA,eAAeH,SAAf","sourcesContent":["import _curry2 from \"./internal/_curry2.js\";\r\n/**\r\n * Takes a list and returns a list of lists where each sublist's elements are\r\n * all satisfied pairwise comparison according to the provided function.\r\n * Only adjacent elements are passed to the comparison function.\r\n *\r\n * @func\r\n * @memberOf R\r\n * @since v0.21.0\r\n * @category List\r\n * @sig ((a, a) → Boolean) → [a] → [[a]]\r\n * @param {Function} fn Function for determining whether two given (adjacent)\r\n *        elements should be in the same group\r\n * @param {Array} list The array to group. Also accepts a string, which will be\r\n *        treated as a list of characters.\r\n * @return {List} A list that contains sublists of elements,\r\n *         whose concatenations are equal to the original list.\r\n * @example\r\n *\r\n * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])\r\n * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]\r\n *\r\n * R.groupWith((a, b) => a + 1 === b, [0, 1, 1, 2, 3, 5, 8, 13, 21])\r\n * //=> [[0, 1], [1, 2, 3], [5], [8], [13], [21]]\r\n *\r\n * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])\r\n * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]\r\n *\r\n * R.groupWith(R.eqBy(isVowel), 'aestiou')\r\n * //=> ['ae', 'st', 'iou']\r\n */\r\n\r\nvar groupWith =\r\n/*#__PURE__*/\r\n_curry2(function (fn, list) {\r\n  var res = [];\r\n  var idx = 0;\r\n  var len = list.length;\r\n\r\n  while (idx < len) {\r\n    var nextidx = idx + 1;\r\n\r\n    while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {\r\n      nextidx += 1;\r\n    }\r\n\r\n    res.push(list.slice(idx, nextidx));\r\n    idx = nextidx;\r\n  }\r\n\r\n  return res;\r\n});\r\n\r\nexport default groupWith;"]},"metadata":{},"sourceType":"module"}