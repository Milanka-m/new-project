{"ast":null,"code":"import _asyncToGenerator from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _regeneratorRuntime from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport { useCallback, useEffect } from 'react';\nimport { getGatekeeperEndpoint } from '../solana/config';\nimport logger from '../logger';\nimport { GatekeeperRecordState, State, CivicPassMessageAction, RefreshTokenState, GatewayStatus } from '../types';\nimport useChain from './useChain';\nimport useRefresh from './useRefresh';\nimport useWalletHooks from './useWalletHooks';\nimport { gatewayTokenActionCreator } from '../actionCreator';\nimport usePowo from './usePOWO';\nimport useGatekeeper from './useGatekeeper';\nimport useGatekeeperRecord from './useGatekeeperRecord';\nexport var shouldRefreshToken = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(state, gatewayToken, useWallet, powoRequested) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (gatewayToken) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\", false);\n\n          case 2:\n            if (!(gatewayToken.state !== State.ACTIVE)) {\n              _context.next = 4;\n              break;\n            }\n\n            return _context.abrupt(\"return\", false);\n\n          case 4:\n            if (!(!useWallet || !useWallet.publicKey || powoRequested)) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\", false);\n\n          case 6:\n            return _context.abrupt(\"return\", state !== GatekeeperRecordState.ISSUED);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function shouldRefreshToken(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\r\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\r\n * 1. the creation of a new gateway token for a new user\r\n * 2. the refreshing of an existing token for an existing user\r\n *\r\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\r\n *\r\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\r\n * @param {Partial<RootState>} state\r\n * @param {React.Dispatch<Action>} dispatch\r\n * @returns void\r\n */\n\nvar useOrchestration = function useOrchestration(_ref2, state, dispatch) {\n  var wallet = _ref2.wallet,\n      stage = _ref2.stage,\n      chainImplementation = _ref2.chainImplementation,\n      gatekeeperClient = _ref2.gatekeeperClient;\n\n  var _useWalletHooks = useWalletHooks(wallet, state, dispatch),\n      expectWalletConnected = _useWalletHooks.expectWalletConnected;\n\n  var gatekeeperEndpoint = getGatekeeperEndpoint(stage); // Register our hooks here\n\n  var _useRefresh = useRefresh({\n    stage: stage,\n    gatekeeperClient: gatekeeperClient\n  }, state, dispatch),\n      setRefreshPoll = _useRefresh.setRefreshPoll,\n      refreshTokenWithProof = _useRefresh.refreshTokenWithProof;\n\n  var _usePowo = usePowo({\n    wallet: wallet,\n    chainImplementation: chainImplementation\n  }, state, dispatch),\n      waitForConfirmPOWO = _usePowo.waitForConfirmPOWO,\n      waitForPOWO = _usePowo.waitForPOWO;\n\n  var _useGatekeeper = useGatekeeper({\n    wallet: wallet,\n    stage: stage,\n    gatekeeperClient: gatekeeperClient\n  }, state, dispatch),\n      waitForGatekeeperIssuanceRequest = _useGatekeeper.waitForGatekeeperIssuanceRequest;\n\n  useGatekeeperRecord({\n    wallet: wallet,\n    gatekeeperClient: gatekeeperClient,\n    httpConfig: chainImplementation.httpConfig\n  }, state, dispatch);\n  useChain({\n    wallet: wallet,\n    chainImplementation: chainImplementation\n  }, state, dispatch);\n  var gatewayToken = state.gatewayToken,\n      tokenRequested = state.tokenRequested,\n      refreshIntervalId = state.refreshIntervalId,\n      powoRequested = state.powoRequested,\n      refreshInProgress = state.refreshInProgress,\n      walletToRefresh = state.walletToRefresh,\n      civicPass = state.civicPass,\n      refreshTokenState = state.refreshTokenState,\n      gatewayStatus = state.gatewayStatus;\n  /**\r\n   * Refresh Flows ----------------------------------------------------------------\r\n   */\n\n  /**\r\n   * wait until we have a payload that has been emitted by the CivicPass iframe\r\n   * then resolve the promise\r\n   */\n\n  var waitForCivicPassRefreshResponsePayload = useCallback(function () {\n    expectWalletConnected();\n    logger.debug('waitForCivicPassRefreshResponsePayload');\n    var result = new Promise(function (resolve) {\n      var responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      var refreshPayload = responsePayload && responsePayload[CivicPassMessageAction.REFRESH];\n      logger.debug('Refresh payload...', refreshPayload);\n\n      if (refreshPayload) {\n        resolve(refreshPayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\r\n   * wait until a gateway token exists in state before resolving the promise\r\n   */\n\n  var waitForGatewayToken = useCallback(function () {\n    expectWalletConnected();\n    return new Promise(function (resolve) {\n      logger.debug('waitForGatewayToken gatewayToken', !!gatewayToken);\n      if (gatewayToken) resolve(gatewayToken);\n    });\n  }, [gatewayToken, expectWalletConnected]);\n  var checkRefreshRequired = useCallback( /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connectedWallet) {\n      var useWallet, record, shouldRefresh;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              useWallet = walletToRefresh || connectedWallet; // prefer the wallet set in state, this handles polling after disconnect\n              // Check preconditions for refresh:\n\n              _context2.next = 3;\n              return waitForGatewayToken();\n\n            case 3:\n              if (gatewayToken) {\n                _context2.next = 5;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 5:\n              _context2.next = 7;\n              return gatekeeperClient().getGatekeeperRecordWithPayload(gatewayToken.owner);\n\n            case 7:\n              record = _context2.sent;\n              _context2.next = 10;\n              return shouldRefreshToken(record.state, gatewayToken, useWallet, powoRequested);\n\n            case 10:\n              shouldRefresh = _context2.sent;\n              dispatch({\n                type: 'getGatekeeperRecord_success',\n                gatekeeperRecord: record\n              });\n\n              if (shouldRefresh) {\n                _context2.next = 17;\n                break;\n              }\n\n              logger.debug('Refresh not needed. Skipping this attempt.');\n              dispatch({\n                type: 'refresh_complete'\n              });\n              setRefreshPoll(useWallet);\n              return _context2.abrupt(\"return\");\n\n            case 17:\n              logger.debug('Refresh required. Running the refresh flow.');\n              clearInterval(refreshIntervalId);\n              dispatch({\n                type: 'refresh_start'\n              });\n              dispatch({\n                type: 'civicPass_check_token_status'\n              });\n              dispatch({\n                type: 'refresh_clear_interval'\n              });\n\n            case 22:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }(), [gatekeeperEndpoint, gatewayToken, powoRequested, refreshInProgress, refreshIntervalId, wallet, walletToRefresh]);\n  /**\r\n   * Check if the user needs to refresh their roken\r\n   */\n\n  useEffect(function () {\n    if (refreshTokenState === RefreshTokenState.CHECK_TOKEN_EXPIRATION) {\n      logger.debug('Checking if refresh required');\n      checkRefreshRequired();\n    }\n  }, [refreshTokenState]);\n  /**\r\n   * If the user cancels out of the refresh flow start the refresh interval\r\n   */\n\n  useEffect(function () {\n    if (refreshTokenState === RefreshTokenState.CANCELLED || refreshTokenState === RefreshTokenState.FAILED) {\n      logger.debug('User canceled out of the refresh flow');\n      setRefreshPoll(wallet);\n    }\n  }, [refreshTokenState]);\n  /**\r\n   * When we have a token start polling to determine the refresh state\r\n   */\n\n  useEffect(function () {\n    if (gatewayStatus === GatewayStatus.ACTIVE) {\n      logger.debug('Start polling for the record');\n      setRefreshPoll(wallet);\n    }\n  }, [gatewayStatus]);\n  /**\r\n   * Issuance Flows ----------------------------------------------------------------\r\n   */\n\n  /**\r\n   * poll until a gatekeeper record is found, once active check the chain for a token\r\n   * then dispatch a tokenChange event that will result in the token getting saved to state\r\n   * start token refresh polling once a valid token is set\r\n   */\n\n  var waitForCreatedGatekeeperRecord = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var actionCreator;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!wallet) {\n              _context3.next = 5;\n              break;\n            }\n\n            logger.debug('waitForCreatedGatekeeperRecord');\n            actionCreator = gatewayTokenActionCreator({\n              gatekeeperClient: gatekeeperClient,\n              wallet: wallet,\n              chainImplementation: chainImplementation,\n              dispatch: dispatch\n            });\n            _context3.next = 5;\n            return actionCreator.waitForGatewayToken();\n\n          case 5:\n            return _context3.abrupt(\"return\", null);\n\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  })), [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n  /**\r\n   * wait until a presentation request id has been emitted by the CivicPass iframe\r\n   * then resolve the promise\r\n   */\n\n  var waitForCivicPassIssuanceResponsePayload = useCallback(function () {\n    expectWalletConnected();\n    logger.debug('waitForCivicPassIssuanceResponsePayload');\n    var result = new Promise(function (resolve) {\n      var responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      var issuancePayload = responsePayload && responsePayload[CivicPassMessageAction.ISSUANCE];\n      logger.debug('Issuance payload...', issuancePayload);\n\n      if (issuancePayload !== undefined) {\n        resolve(issuancePayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\r\n   * wait until the user has requested a gateway token before resolving the promise\r\n   */\n\n  var waitForTokenRequested = useCallback(function () {\n    expectWalletConnected();\n    return new Promise(function (resolve) {\n      logger.debug('waitForTokenRequested tokenRequested', tokenRequested);\n      if (tokenRequested) resolve(true);\n    });\n  }, [tokenRequested, expectWalletConnected]);\n  /**\r\n   * wait until the user has requested a gateway token before resolving the promise\r\n   */\n\n  var checkForRequiredProof = useCallback( /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref5) {\n      var requiresProofOfWalletOwnership, payload, result;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              requiresProofOfWalletOwnership = _ref5.requiresProofOfWalletOwnership, payload = _ref5.payload;\n\n              if (!requiresProofOfWalletOwnership) {\n                _context4.next = 6;\n                break;\n              }\n\n              _context4.next = 4;\n              return waitForConfirmPOWO(payload).then(waitForPOWO);\n\n            case 4:\n              result = _context4.sent;\n              return _context4.abrupt(\"return\", result);\n\n            case 6:\n              return _context4.abrupt(\"return\", {\n                payload: payload\n              });\n\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x6) {\n      return _ref6.apply(this, arguments);\n    };\n  }(), [waitForConfirmPOWO, waitForPOWO]);\n  /**\r\n   * New token request flow:\r\n   * wait for the user to request a new token\r\n   * wait for the iframe to return a payload\r\n   * wait for the user to confirm they've read the proof of ownership dialogue\r\n   * wait for the user to provide proof of ownership\r\n   * wait for a call to the gatekeeper to request a new token issuance\r\n   * wait for a gatekeeper record to be created\r\n   * once this flow is complete a new Gatekeeper token should be available and set in state\r\n   */\n\n  useEffect(function () {\n    if (wallet && wallet.publicKey) {\n      logger.debug('newTokenRequestFlow');\n      waitForTokenRequested().then(waitForCivicPassIssuanceResponsePayload).then(checkForRequiredProof).then(waitForGatekeeperIssuanceRequest).then(waitForCreatedGatekeeperRecord).then(function () {\n        return setRefreshPoll(wallet);\n      }).catch(function (error) {\n        return logger.error('ERROR newTokenRequestFlow', error);\n      });\n    }\n  }, [waitForTokenRequested, waitForCivicPassIssuanceResponsePayload, checkForRequiredProof, waitForGatekeeperIssuanceRequest, waitForCreatedGatekeeperRecord]);\n  /**\r\n   * Refresh flow:\r\n   * wait refresh to be triggered from the iFrame\r\n   * wait for the iframe to return a payload\r\n   * wait for the user to confirm they've read the proof of ownership dialogue\r\n   * wait for the user to provide proof of ownership\r\n   * wait for a call to the gatekeeper to refresh the token\r\n   * start the polling interval\r\n   */\n\n  var refreshFlow = useCallback( /*#__PURE__*/function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(connectedWallet) {\n      var useWallet;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              useWallet = walletToRefresh || connectedWallet; // Do the refresh flow.\n\n              waitForCivicPassRefreshResponsePayload().then(checkForRequiredProof).then(refreshTokenWithProof(useWallet)).then(function () {\n                return setRefreshPoll(useWallet);\n              }).then(function () {\n                dispatch({\n                  type: 'refresh_complete'\n                });\n              }).catch(function (error) {\n                logger.error('refreshFlow', error);\n                logger.error('refreshToken error', error);\n                dispatch({\n                  type: 'refresh_complete'\n                });\n                setRefreshPoll(useWallet);\n              });\n\n            case 2:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    return function (_x7) {\n      return _ref7.apply(this, arguments);\n    };\n  }(), [gatekeeperEndpoint, gatewayToken, powoRequested, refreshInProgress, waitForConfirmPOWO, waitForGatewayToken, waitForPOWO, wallet, walletToRefresh, checkForRequiredProof]);\n  /**\r\n   * Start the refresh flow\r\n   */\n\n  useEffect(function () {\n    if (refreshTokenState === RefreshTokenState.REQUIRES_POWO) {\n      logger.debug('Start the refresh flow');\n      refreshFlow(wallet);\n    }\n  }, [wallet, refreshTokenState]);\n};\n\nexport default useOrchestration;","map":{"version":3,"sources":["D:/Lianok/dev/new-project/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useOrchestration.js"],"names":["useCallback","useEffect","getGatekeeperEndpoint","logger","GatekeeperRecordState","State","CivicPassMessageAction","RefreshTokenState","GatewayStatus","useChain","useRefresh","useWalletHooks","gatewayTokenActionCreator","usePowo","useGatekeeper","useGatekeeperRecord","shouldRefreshToken","state","gatewayToken","useWallet","powoRequested","ACTIVE","publicKey","ISSUED","useOrchestration","dispatch","wallet","stage","chainImplementation","gatekeeperClient","expectWalletConnected","gatekeeperEndpoint","setRefreshPoll","refreshTokenWithProof","waitForConfirmPOWO","waitForPOWO","waitForGatekeeperIssuanceRequest","httpConfig","tokenRequested","refreshIntervalId","refreshInProgress","walletToRefresh","civicPass","refreshTokenState","gatewayStatus","waitForCivicPassRefreshResponsePayload","debug","result","Promise","resolve","responsePayload","refreshPayload","REFRESH","waitForGatewayToken","checkRefreshRequired","connectedWallet","getGatekeeperRecordWithPayload","owner","record","shouldRefresh","type","gatekeeperRecord","clearInterval","CHECK_TOKEN_EXPIRATION","CANCELLED","FAILED","waitForCreatedGatekeeperRecord","actionCreator","waitForCivicPassIssuanceResponsePayload","issuancePayload","ISSUANCE","undefined","waitForTokenRequested","checkForRequiredProof","requiresProofOfWalletOwnership","payload","then","catch","error","refreshFlow","REQUIRES_POWO"],"mappings":"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","sourcesContent":["import { useCallback, useEffect } from 'react';\r\nimport { getGatekeeperEndpoint } from '../solana/config';\r\nimport logger from '../logger';\r\nimport { GatekeeperRecordState, State, CivicPassMessageAction, RefreshTokenState, GatewayStatus, } from '../types';\r\nimport useChain from './useChain';\r\nimport useRefresh from './useRefresh';\r\nimport useWalletHooks from './useWalletHooks';\r\nimport { gatewayTokenActionCreator } from '../actionCreator';\r\nimport usePowo from './usePOWO';\r\nimport useGatekeeper from './useGatekeeper';\r\nimport useGatekeeperRecord from './useGatekeeperRecord';\r\nexport const shouldRefreshToken = async (state, gatewayToken, useWallet, powoRequested) => {\r\n    if (!gatewayToken)\r\n        return false;\r\n    if (gatewayToken.state !== State.ACTIVE)\r\n        return false;\r\n    if (!useWallet || !useWallet.publicKey || powoRequested)\r\n        return false;\r\n    return state !== GatekeeperRecordState.ISSUED;\r\n};\r\n/**\r\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\r\n * 1. the creation of a new gateway token for a new user\r\n * 2. the refreshing of an existing token for an existing user\r\n *\r\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\r\n *\r\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\r\n * @param {Partial<RootState>} state\r\n * @param {React.Dispatch<Action>} dispatch\r\n * @returns void\r\n */\r\nconst useOrchestration = ({ wallet, stage, chainImplementation, gatekeeperClient, }, state, dispatch) => {\r\n    const { expectWalletConnected } = useWalletHooks(wallet, state, dispatch);\r\n    const gatekeeperEndpoint = getGatekeeperEndpoint(stage);\r\n    // Register our hooks here\r\n    const { setRefreshPoll, refreshTokenWithProof } = useRefresh({ stage, gatekeeperClient }, state, dispatch);\r\n    const { waitForConfirmPOWO, waitForPOWO } = usePowo({ wallet, chainImplementation }, state, dispatch);\r\n    const { waitForGatekeeperIssuanceRequest } = useGatekeeper({ wallet, stage, gatekeeperClient }, state, dispatch);\r\n    useGatekeeperRecord({ wallet, gatekeeperClient, httpConfig: chainImplementation.httpConfig }, state, dispatch);\r\n    useChain({ wallet, chainImplementation }, state, dispatch);\r\n    const { gatewayToken, tokenRequested, refreshIntervalId, powoRequested, refreshInProgress, walletToRefresh, civicPass, refreshTokenState, gatewayStatus, } = state;\r\n    /**\r\n     * Refresh Flows ----------------------------------------------------------------\r\n     */\r\n    /**\r\n     * wait until we have a payload that has been emitted by the CivicPass iframe\r\n     * then resolve the promise\r\n     */\r\n    const waitForCivicPassRefreshResponsePayload = useCallback(() => {\r\n        expectWalletConnected();\r\n        logger.debug('waitForCivicPassRefreshResponsePayload');\r\n        const result = new Promise((resolve) => {\r\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\r\n            const refreshPayload = responsePayload && responsePayload[CivicPassMessageAction.REFRESH];\r\n            logger.debug('Refresh payload...', refreshPayload);\r\n            if (refreshPayload) {\r\n                resolve(refreshPayload);\r\n            }\r\n        });\r\n        return result;\r\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\r\n    /**\r\n     * wait until a gateway token exists in state before resolving the promise\r\n     */\r\n    const waitForGatewayToken = useCallback(() => {\r\n        expectWalletConnected();\r\n        return new Promise((resolve) => {\r\n            logger.debug('waitForGatewayToken gatewayToken', !!gatewayToken);\r\n            if (gatewayToken)\r\n                resolve(gatewayToken);\r\n        });\r\n    }, [gatewayToken, expectWalletConnected]);\r\n    const checkRefreshRequired = useCallback(async (connectedWallet) => {\r\n        const useWallet = walletToRefresh || connectedWallet; // prefer the wallet set in state, this handles polling after disconnect\r\n        // Check preconditions for refresh:\r\n        await waitForGatewayToken();\r\n        if (!gatewayToken)\r\n            return;\r\n        const record = await gatekeeperClient().getGatekeeperRecordWithPayload(gatewayToken.owner);\r\n        const shouldRefresh = await shouldRefreshToken(record.state, gatewayToken, useWallet, powoRequested);\r\n        dispatch({ type: 'getGatekeeperRecord_success', gatekeeperRecord: record });\r\n        if (!shouldRefresh) {\r\n            logger.debug('Refresh not needed. Skipping this attempt.');\r\n            dispatch({ type: 'refresh_complete' });\r\n            setRefreshPoll(useWallet);\r\n            return;\r\n        }\r\n        logger.debug('Refresh required. Running the refresh flow.');\r\n        clearInterval(refreshIntervalId);\r\n        dispatch({ type: 'refresh_start' });\r\n        dispatch({ type: 'civicPass_check_token_status' });\r\n        dispatch({ type: 'refresh_clear_interval' });\r\n    }, [gatekeeperEndpoint, gatewayToken, powoRequested, refreshInProgress, refreshIntervalId, wallet, walletToRefresh]);\r\n    /**\r\n     * Check if the user needs to refresh their roken\r\n     */\r\n    useEffect(() => {\r\n        if (refreshTokenState === RefreshTokenState.CHECK_TOKEN_EXPIRATION) {\r\n            logger.debug('Checking if refresh required');\r\n            checkRefreshRequired();\r\n        }\r\n    }, [refreshTokenState]);\r\n    /**\r\n     * If the user cancels out of the refresh flow start the refresh interval\r\n     */\r\n    useEffect(() => {\r\n        if (refreshTokenState === RefreshTokenState.CANCELLED || refreshTokenState === RefreshTokenState.FAILED) {\r\n            logger.debug('User canceled out of the refresh flow');\r\n            setRefreshPoll(wallet);\r\n        }\r\n    }, [refreshTokenState]);\r\n    /**\r\n     * When we have a token start polling to determine the refresh state\r\n     */\r\n    useEffect(() => {\r\n        if (gatewayStatus === GatewayStatus.ACTIVE) {\r\n            logger.debug('Start polling for the record');\r\n            setRefreshPoll(wallet);\r\n        }\r\n    }, [gatewayStatus]);\r\n    /**\r\n     * Issuance Flows ----------------------------------------------------------------\r\n     */\r\n    /**\r\n     * poll until a gatekeeper record is found, once active check the chain for a token\r\n     * then dispatch a tokenChange event that will result in the token getting saved to state\r\n     * start token refresh polling once a valid token is set\r\n     */\r\n    const waitForCreatedGatekeeperRecord = useCallback(async () => {\r\n        if (wallet) {\r\n            logger.debug('waitForCreatedGatekeeperRecord');\r\n            const actionCreator = gatewayTokenActionCreator({\r\n                gatekeeperClient,\r\n                wallet,\r\n                chainImplementation,\r\n                dispatch,\r\n            });\r\n            await actionCreator.waitForGatewayToken();\r\n        }\r\n        return null;\r\n    }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\r\n    /**\r\n     * wait until a presentation request id has been emitted by the CivicPass iframe\r\n     * then resolve the promise\r\n     */\r\n    const waitForCivicPassIssuanceResponsePayload = useCallback(() => {\r\n        expectWalletConnected();\r\n        logger.debug('waitForCivicPassIssuanceResponsePayload');\r\n        const result = new Promise((resolve) => {\r\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\r\n            const issuancePayload = responsePayload && responsePayload[CivicPassMessageAction.ISSUANCE];\r\n            logger.debug('Issuance payload...', issuancePayload);\r\n            if (issuancePayload !== undefined) {\r\n                resolve(issuancePayload);\r\n            }\r\n        });\r\n        return result;\r\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\r\n    /**\r\n     * wait until the user has requested a gateway token before resolving the promise\r\n     */\r\n    const waitForTokenRequested = useCallback(() => {\r\n        expectWalletConnected();\r\n        return new Promise((resolve) => {\r\n            logger.debug('waitForTokenRequested tokenRequested', tokenRequested);\r\n            if (tokenRequested)\r\n                resolve(true);\r\n        });\r\n    }, [tokenRequested, expectWalletConnected]);\r\n    /**\r\n     * wait until the user has requested a gateway token before resolving the promise\r\n     */\r\n    const checkForRequiredProof = useCallback(async ({ requiresProofOfWalletOwnership, payload, }) => {\r\n        if (requiresProofOfWalletOwnership) {\r\n            const result = await waitForConfirmPOWO(payload).then(waitForPOWO);\r\n            return result;\r\n        }\r\n        return { payload };\r\n    }, [waitForConfirmPOWO, waitForPOWO]);\r\n    /**\r\n     * New token request flow:\r\n     * wait for the user to request a new token\r\n     * wait for the iframe to return a payload\r\n     * wait for the user to confirm they've read the proof of ownership dialogue\r\n     * wait for the user to provide proof of ownership\r\n     * wait for a call to the gatekeeper to request a new token issuance\r\n     * wait for a gatekeeper record to be created\r\n     * once this flow is complete a new Gatekeeper token should be available and set in state\r\n     */\r\n    useEffect(() => {\r\n        if (wallet && wallet.publicKey) {\r\n            logger.debug('newTokenRequestFlow');\r\n            waitForTokenRequested()\r\n                .then(waitForCivicPassIssuanceResponsePayload)\r\n                .then(checkForRequiredProof)\r\n                .then(waitForGatekeeperIssuanceRequest)\r\n                .then(waitForCreatedGatekeeperRecord)\r\n                .then(() => setRefreshPoll(wallet))\r\n                .catch((error) => logger.error('ERROR newTokenRequestFlow', error));\r\n        }\r\n    }, [\r\n        waitForTokenRequested,\r\n        waitForCivicPassIssuanceResponsePayload,\r\n        checkForRequiredProof,\r\n        waitForGatekeeperIssuanceRequest,\r\n        waitForCreatedGatekeeperRecord,\r\n    ]);\r\n    /**\r\n     * Refresh flow:\r\n     * wait refresh to be triggered from the iFrame\r\n     * wait for the iframe to return a payload\r\n     * wait for the user to confirm they've read the proof of ownership dialogue\r\n     * wait for the user to provide proof of ownership\r\n     * wait for a call to the gatekeeper to refresh the token\r\n     * start the polling interval\r\n     */\r\n    const refreshFlow = useCallback(async (connectedWallet) => {\r\n        const useWallet = walletToRefresh || connectedWallet;\r\n        // Do the refresh flow.\r\n        waitForCivicPassRefreshResponsePayload()\r\n            .then(checkForRequiredProof)\r\n            .then(refreshTokenWithProof(useWallet))\r\n            .then(() => setRefreshPoll(useWallet))\r\n            .then(() => {\r\n            dispatch({ type: 'refresh_complete' });\r\n        })\r\n            .catch((error) => {\r\n            logger.error('refreshFlow', error);\r\n            logger.error('refreshToken error', error);\r\n            dispatch({ type: 'refresh_complete' });\r\n            setRefreshPoll(useWallet);\r\n        });\r\n    }, [\r\n        gatekeeperEndpoint,\r\n        gatewayToken,\r\n        powoRequested,\r\n        refreshInProgress,\r\n        waitForConfirmPOWO,\r\n        waitForGatewayToken,\r\n        waitForPOWO,\r\n        wallet,\r\n        walletToRefresh,\r\n        checkForRequiredProof,\r\n    ]);\r\n    /**\r\n     * Start the refresh flow\r\n     */\r\n    useEffect(() => {\r\n        if (refreshTokenState === RefreshTokenState.REQUIRES_POWO) {\r\n            logger.debug('Start the refresh flow');\r\n            refreshFlow(wallet);\r\n        }\r\n    }, [wallet, refreshTokenState]);\r\n};\r\nexport default useOrchestration;\r\n"]},"metadata":{},"sourceType":"module"}