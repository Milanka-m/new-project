{"ast":null,"code":"import { useCallback, useEffect } from 'react';\nimport { getGatekeeperEndpoint } from '../solana/config';\nimport logger from '../logger';\nimport { GatekeeperRecordState, State, CivicPassMessageAction, RefreshTokenState, GatewayStatus } from '../types';\nimport useChain from './useChain';\nimport useRefresh from './useRefresh';\nimport useWalletHooks from './useWalletHooks';\nimport { gatewayTokenActionCreator } from '../actionCreator';\nimport usePowo from './usePOWO';\nimport useGatekeeper from './useGatekeeper';\nimport useGatekeeperRecord from './useGatekeeperRecord';\nexport const shouldRefreshToken = async (state, gatewayToken, useWallet, powoRequested) => {\n  if (!gatewayToken) return false;\n  if (gatewayToken.state !== State.ACTIVE) return false;\n  if (!useWallet || !useWallet.publicKey || powoRequested) return false;\n  return state !== GatekeeperRecordState.ISSUED;\n};\n/**\r\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\r\n * 1. the creation of a new gateway token for a new user\r\n * 2. the refreshing of an existing token for an existing user\r\n *\r\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\r\n *\r\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\r\n * @param {Partial<RootState>} state\r\n * @param {React.Dispatch<Action>} dispatch\r\n * @returns void\r\n */\n\nconst useOrchestration = (_ref, state, dispatch) => {\n  let {\n    wallet,\n    stage,\n    chainImplementation,\n    gatekeeperClient\n  } = _ref;\n  const {\n    expectWalletConnected\n  } = useWalletHooks(wallet, state, dispatch);\n  const gatekeeperEndpoint = getGatekeeperEndpoint(stage); // Register our hooks here\n\n  const {\n    setRefreshPoll,\n    refreshTokenWithProof\n  } = useRefresh({\n    stage,\n    gatekeeperClient\n  }, state, dispatch);\n  const {\n    waitForConfirmPOWO,\n    waitForPOWO\n  } = usePowo({\n    wallet,\n    chainImplementation\n  }, state, dispatch);\n  const {\n    waitForGatekeeperIssuanceRequest\n  } = useGatekeeper({\n    wallet,\n    stage,\n    gatekeeperClient\n  }, state, dispatch);\n  useGatekeeperRecord({\n    wallet,\n    gatekeeperClient,\n    httpConfig: chainImplementation.httpConfig\n  }, state, dispatch);\n  useChain({\n    wallet,\n    chainImplementation\n  }, state, dispatch);\n  const {\n    gatewayToken,\n    tokenRequested,\n    refreshIntervalId,\n    powoRequested,\n    refreshInProgress,\n    walletToRefresh,\n    civicPass,\n    refreshTokenState,\n    gatewayStatus\n  } = state;\n  /**\r\n   * Refresh Flows ----------------------------------------------------------------\r\n   */\n\n  /**\r\n   * wait until we have a payload that has been emitted by the CivicPass iframe\r\n   * then resolve the promise\r\n   */\n\n  const waitForCivicPassRefreshResponsePayload = useCallback(() => {\n    expectWalletConnected();\n    logger.debug('waitForCivicPassRefreshResponsePayload');\n    const result = new Promise(resolve => {\n      const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      const refreshPayload = responsePayload && responsePayload[CivicPassMessageAction.REFRESH];\n      logger.debug('Refresh payload...', refreshPayload);\n\n      if (refreshPayload) {\n        resolve(refreshPayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\r\n   * wait until a gateway token exists in state before resolving the promise\r\n   */\n\n  const waitForGatewayToken = useCallback(() => {\n    expectWalletConnected();\n    return new Promise(resolve => {\n      logger.debug('waitForGatewayToken gatewayToken', !!gatewayToken);\n      if (gatewayToken) resolve(gatewayToken);\n    });\n  }, [gatewayToken, expectWalletConnected]);\n  const checkRefreshRequired = useCallback(async connectedWallet => {\n    const useWallet = walletToRefresh || connectedWallet; // prefer the wallet set in state, this handles polling after disconnect\n    // Check preconditions for refresh:\n\n    await waitForGatewayToken();\n    if (!gatewayToken) return;\n    const record = await gatekeeperClient().getGatekeeperRecordWithPayload(gatewayToken.owner);\n    const shouldRefresh = await shouldRefreshToken(record.state, gatewayToken, useWallet, powoRequested);\n    dispatch({\n      type: 'getGatekeeperRecord_success',\n      gatekeeperRecord: record\n    });\n\n    if (!shouldRefresh) {\n      logger.debug('Refresh not needed. Skipping this attempt.');\n      dispatch({\n        type: 'refresh_complete'\n      });\n      setRefreshPoll(useWallet);\n      return;\n    }\n\n    logger.debug('Refresh required. Running the refresh flow.');\n    clearInterval(refreshIntervalId);\n    dispatch({\n      type: 'refresh_start'\n    });\n    dispatch({\n      type: 'civicPass_check_token_status'\n    });\n    dispatch({\n      type: 'refresh_clear_interval'\n    });\n  }, [gatekeeperEndpoint, gatewayToken, powoRequested, refreshInProgress, refreshIntervalId, wallet, walletToRefresh]);\n  /**\r\n   * Check if the user needs to refresh their roken\r\n   */\n\n  useEffect(() => {\n    if (refreshTokenState === RefreshTokenState.CHECK_TOKEN_EXPIRATION) {\n      logger.debug('Checking if refresh required');\n      checkRefreshRequired();\n    }\n  }, [refreshTokenState]);\n  /**\r\n   * If the user cancels out of the refresh flow start the refresh interval\r\n   */\n\n  useEffect(() => {\n    if (refreshTokenState === RefreshTokenState.CANCELLED || refreshTokenState === RefreshTokenState.FAILED) {\n      logger.debug('User canceled out of the refresh flow');\n      setRefreshPoll(wallet);\n    }\n  }, [refreshTokenState]);\n  /**\r\n   * When we have a token start polling to determine the refresh state\r\n   */\n\n  useEffect(() => {\n    if (gatewayStatus === GatewayStatus.ACTIVE) {\n      logger.debug('Start polling for the record');\n      setRefreshPoll(wallet);\n    }\n  }, [gatewayStatus]);\n  /**\r\n   * Issuance Flows ----------------------------------------------------------------\r\n   */\n\n  /**\r\n   * poll until a gatekeeper record is found, once active check the chain for a token\r\n   * then dispatch a tokenChange event that will result in the token getting saved to state\r\n   * start token refresh polling once a valid token is set\r\n   */\n\n  const waitForCreatedGatekeeperRecord = useCallback(async () => {\n    if (wallet) {\n      logger.debug('waitForCreatedGatekeeperRecord');\n      const actionCreator = gatewayTokenActionCreator({\n        gatekeeperClient,\n        wallet,\n        chainImplementation,\n        dispatch\n      });\n      await actionCreator.waitForGatewayToken();\n    }\n\n    return null;\n  }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n  /**\r\n   * wait until a presentation request id has been emitted by the CivicPass iframe\r\n   * then resolve the promise\r\n   */\n\n  const waitForCivicPassIssuanceResponsePayload = useCallback(() => {\n    expectWalletConnected();\n    logger.debug('waitForCivicPassIssuanceResponsePayload');\n    const result = new Promise(resolve => {\n      const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      const issuancePayload = responsePayload && responsePayload[CivicPassMessageAction.ISSUANCE];\n      logger.debug('Issuance payload...', issuancePayload);\n\n      if (issuancePayload !== undefined) {\n        resolve(issuancePayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\r\n   * wait until the user has requested a gateway token before resolving the promise\r\n   */\n\n  const waitForTokenRequested = useCallback(() => {\n    expectWalletConnected();\n    return new Promise(resolve => {\n      logger.debug('waitForTokenRequested tokenRequested', tokenRequested);\n      if (tokenRequested) resolve(true);\n    });\n  }, [tokenRequested, expectWalletConnected]);\n  /**\r\n   * wait until the user has requested a gateway token before resolving the promise\r\n   */\n\n  const checkForRequiredProof = useCallback(async _ref2 => {\n    let {\n      requiresProofOfWalletOwnership,\n      payload\n    } = _ref2;\n\n    if (requiresProofOfWalletOwnership) {\n      const result = await waitForConfirmPOWO(payload).then(waitForPOWO);\n      return result;\n    }\n\n    return {\n      payload\n    };\n  }, [waitForConfirmPOWO, waitForPOWO]);\n  /**\r\n   * New token request flow:\r\n   * wait for the user to request a new token\r\n   * wait for the iframe to return a payload\r\n   * wait for the user to confirm they've read the proof of ownership dialogue\r\n   * wait for the user to provide proof of ownership\r\n   * wait for a call to the gatekeeper to request a new token issuance\r\n   * wait for a gatekeeper record to be created\r\n   * once this flow is complete a new Gatekeeper token should be available and set in state\r\n   */\n\n  useEffect(() => {\n    if (wallet && wallet.publicKey) {\n      logger.debug('newTokenRequestFlow');\n      waitForTokenRequested().then(waitForCivicPassIssuanceResponsePayload).then(checkForRequiredProof).then(waitForGatekeeperIssuanceRequest).then(waitForCreatedGatekeeperRecord).then(() => setRefreshPoll(wallet)).catch(error => logger.error('ERROR newTokenRequestFlow', error));\n    }\n  }, [waitForTokenRequested, waitForCivicPassIssuanceResponsePayload, checkForRequiredProof, waitForGatekeeperIssuanceRequest, waitForCreatedGatekeeperRecord]);\n  /**\r\n   * Refresh flow:\r\n   * wait refresh to be triggered from the iFrame\r\n   * wait for the iframe to return a payload\r\n   * wait for the user to confirm they've read the proof of ownership dialogue\r\n   * wait for the user to provide proof of ownership\r\n   * wait for a call to the gatekeeper to refresh the token\r\n   * start the polling interval\r\n   */\n\n  const refreshFlow = useCallback(async connectedWallet => {\n    const useWallet = walletToRefresh || connectedWallet; // Do the refresh flow.\n\n    waitForCivicPassRefreshResponsePayload().then(checkForRequiredProof).then(refreshTokenWithProof(useWallet)).then(() => setRefreshPoll(useWallet)).then(() => {\n      dispatch({\n        type: 'refresh_complete'\n      });\n    }).catch(error => {\n      logger.error('refreshFlow', error);\n      logger.error('refreshToken error', error);\n      dispatch({\n        type: 'refresh_complete'\n      });\n      setRefreshPoll(useWallet);\n    });\n  }, [gatekeeperEndpoint, gatewayToken, powoRequested, refreshInProgress, waitForConfirmPOWO, waitForGatewayToken, waitForPOWO, wallet, walletToRefresh, checkForRequiredProof]);\n  /**\r\n   * Start the refresh flow\r\n   */\n\n  useEffect(() => {\n    if (refreshTokenState === RefreshTokenState.REQUIRES_POWO) {\n      logger.debug('Start the refresh flow');\n      refreshFlow(wallet);\n    }\n  }, [wallet, refreshTokenState]);\n};\n\nexport default useOrchestration;","map":{"version":3,"sources":["D:/Lianok/dev/new-project/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useOrchestration.js"],"names":["useCallback","useEffect","getGatekeeperEndpoint","logger","GatekeeperRecordState","State","CivicPassMessageAction","RefreshTokenState","GatewayStatus","useChain","useRefresh","useWalletHooks","gatewayTokenActionCreator","usePowo","useGatekeeper","useGatekeeperRecord","shouldRefreshToken","state","gatewayToken","useWallet","powoRequested","ACTIVE","publicKey","ISSUED","useOrchestration","dispatch","wallet","stage","chainImplementation","gatekeeperClient","expectWalletConnected","gatekeeperEndpoint","setRefreshPoll","refreshTokenWithProof","waitForConfirmPOWO","waitForPOWO","waitForGatekeeperIssuanceRequest","httpConfig","tokenRequested","refreshIntervalId","refreshInProgress","walletToRefresh","civicPass","refreshTokenState","gatewayStatus","waitForCivicPassRefreshResponsePayload","debug","result","Promise","resolve","responsePayload","refreshPayload","REFRESH","waitForGatewayToken","checkRefreshRequired","connectedWallet","record","getGatekeeperRecordWithPayload","owner","shouldRefresh","type","gatekeeperRecord","clearInterval","CHECK_TOKEN_EXPIRATION","CANCELLED","FAILED","waitForCreatedGatekeeperRecord","actionCreator","waitForCivicPassIssuanceResponsePayload","issuancePayload","ISSUANCE","undefined","waitForTokenRequested","checkForRequiredProof","requiresProofOfWalletOwnership","payload","then","catch","error","refreshFlow","REQUIRES_POWO"],"mappings":"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","sourcesContent":["import { useCallback, useEffect } from 'react';\r\nimport { getGatekeeperEndpoint } from '../solana/config';\r\nimport logger from '../logger';\r\nimport { GatekeeperRecordState, State, CivicPassMessageAction, RefreshTokenState, GatewayStatus, } from '../types';\r\nimport useChain from './useChain';\r\nimport useRefresh from './useRefresh';\r\nimport useWalletHooks from './useWalletHooks';\r\nimport { gatewayTokenActionCreator } from '../actionCreator';\r\nimport usePowo from './usePOWO';\r\nimport useGatekeeper from './useGatekeeper';\r\nimport useGatekeeperRecord from './useGatekeeperRecord';\r\nexport const shouldRefreshToken = async (state, gatewayToken, useWallet, powoRequested) => {\r\n    if (!gatewayToken)\r\n        return false;\r\n    if (gatewayToken.state !== State.ACTIVE)\r\n        return false;\r\n    if (!useWallet || !useWallet.publicKey || powoRequested)\r\n        return false;\r\n    return state !== GatekeeperRecordState.ISSUED;\r\n};\r\n/**\r\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\r\n * 1. the creation of a new gateway token for a new user\r\n * 2. the refreshing of an existing token for an existing user\r\n *\r\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\r\n *\r\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\r\n * @param {Partial<RootState>} state\r\n * @param {React.Dispatch<Action>} dispatch\r\n * @returns void\r\n */\r\nconst useOrchestration = ({ wallet, stage, chainImplementation, gatekeeperClient, }, state, dispatch) => {\r\n    const { expectWalletConnected } = useWalletHooks(wallet, state, dispatch);\r\n    const gatekeeperEndpoint = getGatekeeperEndpoint(stage);\r\n    // Register our hooks here\r\n    const { setRefreshPoll, refreshTokenWithProof } = useRefresh({ stage, gatekeeperClient }, state, dispatch);\r\n    const { waitForConfirmPOWO, waitForPOWO } = usePowo({ wallet, chainImplementation }, state, dispatch);\r\n    const { waitForGatekeeperIssuanceRequest } = useGatekeeper({ wallet, stage, gatekeeperClient }, state, dispatch);\r\n    useGatekeeperRecord({ wallet, gatekeeperClient, httpConfig: chainImplementation.httpConfig }, state, dispatch);\r\n    useChain({ wallet, chainImplementation }, state, dispatch);\r\n    const { gatewayToken, tokenRequested, refreshIntervalId, powoRequested, refreshInProgress, walletToRefresh, civicPass, refreshTokenState, gatewayStatus, } = state;\r\n    /**\r\n     * Refresh Flows ----------------------------------------------------------------\r\n     */\r\n    /**\r\n     * wait until we have a payload that has been emitted by the CivicPass iframe\r\n     * then resolve the promise\r\n     */\r\n    const waitForCivicPassRefreshResponsePayload = useCallback(() => {\r\n        expectWalletConnected();\r\n        logger.debug('waitForCivicPassRefreshResponsePayload');\r\n        const result = new Promise((resolve) => {\r\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\r\n            const refreshPayload = responsePayload && responsePayload[CivicPassMessageAction.REFRESH];\r\n            logger.debug('Refresh payload...', refreshPayload);\r\n            if (refreshPayload) {\r\n                resolve(refreshPayload);\r\n            }\r\n        });\r\n        return result;\r\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\r\n    /**\r\n     * wait until a gateway token exists in state before resolving the promise\r\n     */\r\n    const waitForGatewayToken = useCallback(() => {\r\n        expectWalletConnected();\r\n        return new Promise((resolve) => {\r\n            logger.debug('waitForGatewayToken gatewayToken', !!gatewayToken);\r\n            if (gatewayToken)\r\n                resolve(gatewayToken);\r\n        });\r\n    }, [gatewayToken, expectWalletConnected]);\r\n    const checkRefreshRequired = useCallback(async (connectedWallet) => {\r\n        const useWallet = walletToRefresh || connectedWallet; // prefer the wallet set in state, this handles polling after disconnect\r\n        // Check preconditions for refresh:\r\n        await waitForGatewayToken();\r\n        if (!gatewayToken)\r\n            return;\r\n        const record = await gatekeeperClient().getGatekeeperRecordWithPayload(gatewayToken.owner);\r\n        const shouldRefresh = await shouldRefreshToken(record.state, gatewayToken, useWallet, powoRequested);\r\n        dispatch({ type: 'getGatekeeperRecord_success', gatekeeperRecord: record });\r\n        if (!shouldRefresh) {\r\n            logger.debug('Refresh not needed. Skipping this attempt.');\r\n            dispatch({ type: 'refresh_complete' });\r\n            setRefreshPoll(useWallet);\r\n            return;\r\n        }\r\n        logger.debug('Refresh required. Running the refresh flow.');\r\n        clearInterval(refreshIntervalId);\r\n        dispatch({ type: 'refresh_start' });\r\n        dispatch({ type: 'civicPass_check_token_status' });\r\n        dispatch({ type: 'refresh_clear_interval' });\r\n    }, [gatekeeperEndpoint, gatewayToken, powoRequested, refreshInProgress, refreshIntervalId, wallet, walletToRefresh]);\r\n    /**\r\n     * Check if the user needs to refresh their roken\r\n     */\r\n    useEffect(() => {\r\n        if (refreshTokenState === RefreshTokenState.CHECK_TOKEN_EXPIRATION) {\r\n            logger.debug('Checking if refresh required');\r\n            checkRefreshRequired();\r\n        }\r\n    }, [refreshTokenState]);\r\n    /**\r\n     * If the user cancels out of the refresh flow start the refresh interval\r\n     */\r\n    useEffect(() => {\r\n        if (refreshTokenState === RefreshTokenState.CANCELLED || refreshTokenState === RefreshTokenState.FAILED) {\r\n            logger.debug('User canceled out of the refresh flow');\r\n            setRefreshPoll(wallet);\r\n        }\r\n    }, [refreshTokenState]);\r\n    /**\r\n     * When we have a token start polling to determine the refresh state\r\n     */\r\n    useEffect(() => {\r\n        if (gatewayStatus === GatewayStatus.ACTIVE) {\r\n            logger.debug('Start polling for the record');\r\n            setRefreshPoll(wallet);\r\n        }\r\n    }, [gatewayStatus]);\r\n    /**\r\n     * Issuance Flows ----------------------------------------------------------------\r\n     */\r\n    /**\r\n     * poll until a gatekeeper record is found, once active check the chain for a token\r\n     * then dispatch a tokenChange event that will result in the token getting saved to state\r\n     * start token refresh polling once a valid token is set\r\n     */\r\n    const waitForCreatedGatekeeperRecord = useCallback(async () => {\r\n        if (wallet) {\r\n            logger.debug('waitForCreatedGatekeeperRecord');\r\n            const actionCreator = gatewayTokenActionCreator({\r\n                gatekeeperClient,\r\n                wallet,\r\n                chainImplementation,\r\n                dispatch,\r\n            });\r\n            await actionCreator.waitForGatewayToken();\r\n        }\r\n        return null;\r\n    }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\r\n    /**\r\n     * wait until a presentation request id has been emitted by the CivicPass iframe\r\n     * then resolve the promise\r\n     */\r\n    const waitForCivicPassIssuanceResponsePayload = useCallback(() => {\r\n        expectWalletConnected();\r\n        logger.debug('waitForCivicPassIssuanceResponsePayload');\r\n        const result = new Promise((resolve) => {\r\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\r\n            const issuancePayload = responsePayload && responsePayload[CivicPassMessageAction.ISSUANCE];\r\n            logger.debug('Issuance payload...', issuancePayload);\r\n            if (issuancePayload !== undefined) {\r\n                resolve(issuancePayload);\r\n            }\r\n        });\r\n        return result;\r\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\r\n    /**\r\n     * wait until the user has requested a gateway token before resolving the promise\r\n     */\r\n    const waitForTokenRequested = useCallback(() => {\r\n        expectWalletConnected();\r\n        return new Promise((resolve) => {\r\n            logger.debug('waitForTokenRequested tokenRequested', tokenRequested);\r\n            if (tokenRequested)\r\n                resolve(true);\r\n        });\r\n    }, [tokenRequested, expectWalletConnected]);\r\n    /**\r\n     * wait until the user has requested a gateway token before resolving the promise\r\n     */\r\n    const checkForRequiredProof = useCallback(async ({ requiresProofOfWalletOwnership, payload, }) => {\r\n        if (requiresProofOfWalletOwnership) {\r\n            const result = await waitForConfirmPOWO(payload).then(waitForPOWO);\r\n            return result;\r\n        }\r\n        return { payload };\r\n    }, [waitForConfirmPOWO, waitForPOWO]);\r\n    /**\r\n     * New token request flow:\r\n     * wait for the user to request a new token\r\n     * wait for the iframe to return a payload\r\n     * wait for the user to confirm they've read the proof of ownership dialogue\r\n     * wait for the user to provide proof of ownership\r\n     * wait for a call to the gatekeeper to request a new token issuance\r\n     * wait for a gatekeeper record to be created\r\n     * once this flow is complete a new Gatekeeper token should be available and set in state\r\n     */\r\n    useEffect(() => {\r\n        if (wallet && wallet.publicKey) {\r\n            logger.debug('newTokenRequestFlow');\r\n            waitForTokenRequested()\r\n                .then(waitForCivicPassIssuanceResponsePayload)\r\n                .then(checkForRequiredProof)\r\n                .then(waitForGatekeeperIssuanceRequest)\r\n                .then(waitForCreatedGatekeeperRecord)\r\n                .then(() => setRefreshPoll(wallet))\r\n                .catch((error) => logger.error('ERROR newTokenRequestFlow', error));\r\n        }\r\n    }, [\r\n        waitForTokenRequested,\r\n        waitForCivicPassIssuanceResponsePayload,\r\n        checkForRequiredProof,\r\n        waitForGatekeeperIssuanceRequest,\r\n        waitForCreatedGatekeeperRecord,\r\n    ]);\r\n    /**\r\n     * Refresh flow:\r\n     * wait refresh to be triggered from the iFrame\r\n     * wait for the iframe to return a payload\r\n     * wait for the user to confirm they've read the proof of ownership dialogue\r\n     * wait for the user to provide proof of ownership\r\n     * wait for a call to the gatekeeper to refresh the token\r\n     * start the polling interval\r\n     */\r\n    const refreshFlow = useCallback(async (connectedWallet) => {\r\n        const useWallet = walletToRefresh || connectedWallet;\r\n        // Do the refresh flow.\r\n        waitForCivicPassRefreshResponsePayload()\r\n            .then(checkForRequiredProof)\r\n            .then(refreshTokenWithProof(useWallet))\r\n            .then(() => setRefreshPoll(useWallet))\r\n            .then(() => {\r\n            dispatch({ type: 'refresh_complete' });\r\n        })\r\n            .catch((error) => {\r\n            logger.error('refreshFlow', error);\r\n            logger.error('refreshToken error', error);\r\n            dispatch({ type: 'refresh_complete' });\r\n            setRefreshPoll(useWallet);\r\n        });\r\n    }, [\r\n        gatekeeperEndpoint,\r\n        gatewayToken,\r\n        powoRequested,\r\n        refreshInProgress,\r\n        waitForConfirmPOWO,\r\n        waitForGatewayToken,\r\n        waitForPOWO,\r\n        wallet,\r\n        walletToRefresh,\r\n        checkForRequiredProof,\r\n    ]);\r\n    /**\r\n     * Start the refresh flow\r\n     */\r\n    useEffect(() => {\r\n        if (refreshTokenState === RefreshTokenState.REQUIRES_POWO) {\r\n            logger.debug('Start the refresh flow');\r\n            refreshFlow(wallet);\r\n        }\r\n    }, [wallet, refreshTokenState]);\r\n};\r\nexport default useOrchestration;\r\n"]},"metadata":{},"sourceType":"module"}