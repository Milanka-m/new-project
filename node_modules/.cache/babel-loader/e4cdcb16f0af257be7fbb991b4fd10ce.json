{"ast":null,"code":"/* The MIT License (MIT)\r\n *\r\n * Copyright 2015-2018 Peter A. Bigot\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\n\n/**\r\n * Support for translating between Buffer instances and JavaScript\r\n * native types.\r\n *\r\n * {@link module:Layout~Layout|Layout} is the basis of a class\r\n * hierarchy that associates property names with sequences of encoded\r\n * bytes.\r\n *\r\n * Layouts are supported for these scalar (numeric) types:\r\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\r\n *   format} with {@link module:Layout.u8|8-bit}, {@link\r\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\r\n *   {@link module:Layout.u32|32-bit}, {@link\r\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\r\n *   representation ranges;\r\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\r\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\r\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\r\n *   {@link module:Layout.u40be|40-bit}, and {@link\r\n *   module:Layout.u48be|48-bit} representation ranges;\r\n * * {@link module:Layout~Int|Signed integers in little-endian\r\n *   format} with {@link module:Layout.s8|8-bit}, {@link\r\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\r\n *   {@link module:Layout.s32|32-bit}, {@link\r\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\r\n *   representation ranges;\r\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\r\n *   with {@link module:Layout.s16be|16-bit}, {@link\r\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\r\n *   {@link module:Layout.s40be|40-bit}, and {@link\r\n *   module:Layout.s48be|48-bit} representation ranges;\r\n * * 64-bit integral values that decode to an exact (if magnitude is\r\n *   less than 2^53) or nearby integral Number in {@link\r\n *   module:Layout.nu64|unsigned little-endian}, {@link\r\n *   module:Layout.nu64be|unsigned big-endian}, {@link\r\n *   module:Layout.ns64|signed little-endian}, and {@link\r\n *   module:Layout.ns64be|unsigned big-endian} encodings;\r\n * * 32-bit floating point values with {@link\r\n *   module:Layout.f32|little-endian} and {@link\r\n *   module:Layout.f32be|big-endian} representations;\r\n * * 64-bit floating point values with {@link\r\n *   module:Layout.f64|little-endian} and {@link\r\n *   module:Layout.f64be|big-endian} representations;\r\n * * {@link module:Layout.const|Constants} that take no space in the\r\n *   encoded expression.\r\n *\r\n * and for these aggregate types:\r\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\r\n *   module:Layout~Layout|Layout}, with JavaScript representation as\r\n *   an Array and constant or data-dependent {@link\r\n *   module:Layout~Sequence#count|length};\r\n * * {@link module:Layout.struct|Structure}s that aggregate a\r\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\r\n *   instances, with JavaScript representation as an Object;\r\n * * {@link module:Layout.union|Union}s that support multiple {@link\r\n *   module:Layout~VariantLayout|variant layouts} over a fixed\r\n *   (padded) or variable (not padded) span of bytes, using an\r\n *   unsigned integer at the start of the data or a separate {@link\r\n *   module:Layout.unionLayoutDiscriminator|layout element} to\r\n *   determine which layout to use when interpreting the buffer\r\n *   contents;\r\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\r\n *   of individual {@link\r\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\r\n *   16, 24, or 32-bit unsigned integer starting at the least- or\r\n *   most-significant bit;\r\n * * {@link module:Layout.cstr|C strings} of varying length;\r\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\r\n *   module:Layout~Blob#length|length} raw data.\r\n *\r\n * All {@link module:Layout~Layout|Layout} instances are immutable\r\n * after construction, to prevent internal state from becoming\r\n * inconsistent.\r\n *\r\n * @local Layout\r\n * @local ExternalLayout\r\n * @local GreedyCount\r\n * @local OffsetLayout\r\n * @local UInt\r\n * @local UIntBE\r\n * @local Int\r\n * @local IntBE\r\n * @local NearUInt64\r\n * @local NearUInt64BE\r\n * @local NearInt64\r\n * @local NearInt64BE\r\n * @local Float\r\n * @local FloatBE\r\n * @local Double\r\n * @local DoubleBE\r\n * @local Sequence\r\n * @local Structure\r\n * @local UnionDiscriminator\r\n * @local UnionLayoutDiscriminator\r\n * @local Union\r\n * @local VariantLayout\r\n * @local BitStructure\r\n * @local BitField\r\n * @local Boolean\r\n * @local Blob\r\n * @local CString\r\n * @local Constant\r\n * @local bindConstructorLayout\r\n * @module Layout\r\n * @license MIT\r\n * @author Peter A. Bigot\r\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\r\n */\n'use strict';\n/**\r\n * Base class for layout objects.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support the {@link\r\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\r\n *\r\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\r\n * parameter must be an integer; a negative value signifies that the\r\n * span is {@link Layout#getSpan|value-specific}.\r\n *\r\n * @param {string} [property] - Initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @abstract\r\n */\n\nvar _assertThisInitialized = require(\"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\assertThisInitialized.js\").default;\n\nvar _createForOfIteratorHelper = require(\"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\createForOfIteratorHelper.js\").default;\n\nvar _inherits = require(\"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\inherits.js\").default;\n\nvar _createSuper = require(\"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\createSuper.js\").default;\n\nvar _classCallCheck = require(\"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\classCallCheck.js\").default;\n\nvar _createClass = require(\"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\createClass.js\").default;\n\nvar Layout = /*#__PURE__*/function () {\n  function Layout(span, property) {\n    _classCallCheck(this, Layout);\n\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n    /** The span of the layout in bytes.\r\n     *\r\n     * Positive values are generally expected.\r\n     *\r\n     * Zero will only appear in {@link Constant}s and in {@link\r\n     * Sequence}s where the {@link Sequence#count|count} is zero.\r\n     *\r\n     * A negative value indicates that the span is value-specific, and\r\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n\n\n    this.span = span;\n    /** The property name used when this layout is represented in an\r\n     * Object.\r\n     *\r\n     * Used only for layouts that {@link Layout#decode|decode} to Object\r\n     * instances.  If left undefined the span of the unnamed layout will\r\n     * be treated as padding: it will not be mutated by {@link\r\n     * Layout#encode|encode} nor represented as a property in the\r\n     * decoded Object. */\n\n    this.property = property;\n  }\n  /** Function to create an Object into which decoded properties will\r\n   * be written.\r\n   *\r\n   * Used only for layouts that {@link Layout#decode|decode} to Object\r\n   * instances, which means:\r\n   * * {@link Structure}\r\n   * * {@link Union}\r\n   * * {@link VariantLayout}\r\n   * * {@link BitStructure}\r\n   *\r\n   * If left undefined the JavaScript representation of these layouts\r\n   * will be Object instances.\r\n   *\r\n   * See {@link bindConstructorLayout}.\r\n   */\n\n\n  _createClass(Layout, [{\n    key: \"makeDestinationObject\",\n    value: function makeDestinationObject() {\n      return {};\n    }\n    /**\r\n     * Decode from a Buffer into an JavaScript value.\r\n     *\r\n     * @param {Buffer} b - the buffer from which encoded data is read.\r\n     *\r\n     * @param {Number} [offset] - the offset at which the encoded data\r\n     * starts.  If absent a zero offset is inferred.\r\n     *\r\n     * @returns {(Number|Array|Object)} - the value of the decoded data.\r\n     *\r\n     * @abstract\r\n     */\n\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      throw new Error('Layout is abstract');\n    }\n    /**\r\n     * Encode a JavaScript value into a Buffer.\r\n     *\r\n     * @param {(Number|Array|Object)} src - the value to be encoded into\r\n     * the buffer.  The type accepted depends on the (sub-)type of {@link\r\n     * Layout}.\r\n     *\r\n     * @param {Buffer} b - the buffer into which encoded data will be\r\n     * written.\r\n     *\r\n     * @param {Number} [offset] - the offset at which the encoded data\r\n     * starts.  If absent a zero offset is inferred.\r\n     *\r\n     * @returns {Number} - the number of bytes encoded, including the\r\n     * space skipped for internal padding, but excluding data such as\r\n     * {@link Sequence#count|lengths} when stored {@link\r\n     * ExternalLayout|externally}.  This is the adjustment to `offset`\r\n     * producing the offset where data for the next layout would be\r\n     * written.\r\n     *\r\n     * @abstract\r\n     */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      throw new Error('Layout is abstract');\n    }\n    /**\r\n     * Calculate the span of a specific instance of a layout.\r\n     *\r\n     * @param {Buffer} b - the buffer that contains an encoded instance.\r\n     *\r\n     * @param {Number} [offset] - the offset at which the encoded instance\r\n     * starts.  If absent a zero offset is inferred.\r\n     *\r\n     * @return {Number} - the number of bytes covered by the layout\r\n     * instance.  If this method is not overridden in a subclass the\r\n     * definition-time constant {@link Layout#span|span} will be\r\n     * returned.\r\n     *\r\n     * @throws {RangeError} - if the length of the value cannot be\r\n     * determined.\r\n     */\n\n  }, {\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 > this.span) {\n        throw new RangeError('indeterminate span');\n      }\n\n      return this.span;\n    }\n    /**\r\n     * Replicate the layout using a new property.\r\n     *\r\n     * This function must be used to get a structurally-equivalent layout\r\n     * with a different name since all {@link Layout} instances are\r\n     * immutable.\r\n     *\r\n     * **NOTE** This is a shallow copy.  All fields except {@link\r\n     * Layout#property|property} are strictly equal to the origin layout.\r\n     *\r\n     * @param {String} property - the value for {@link\r\n     * Layout#property|property} in the replica.\r\n     *\r\n     * @returns {Layout} - the copy with {@link Layout#property|property}\r\n     * set to `property`.\r\n     */\n\n  }, {\n    key: \"replicate\",\n    value: function replicate(property) {\n      var rv = Object.create(this.constructor.prototype);\n      Object.assign(rv, this);\n      rv.property = property;\n      return rv;\n    }\n    /**\r\n     * Create an object from layout properties and an array of values.\r\n     *\r\n     * **NOTE** This function returns `undefined` if invoked on a layout\r\n     * that does not return its value as an Object.  Objects are\r\n     * returned for things that are a {@link Structure}, which includes\r\n     * {@link VariantLayout|variant layouts} if they are structures, and\r\n     * excludes {@link Union}s.  If you want this feature for a union\r\n     * you must use {@link Union.getVariant|getVariant} to select the\r\n     * desired layout.\r\n     *\r\n     * @param {Array} values - an array of values that correspond to the\r\n     * default order for properties.  As with {@link Layout#decode|decode}\r\n     * layout elements that have no property name are skipped when\r\n     * iterating over the array values.  Only the top-level properties are\r\n     * assigned; arguments are not assigned to properties of contained\r\n     * layouts.  Any unused values are ignored.\r\n     *\r\n     * @return {(Object|undefined)}\r\n     */\n\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(values) {\n      return undefined;\n    }\n  }]);\n\n  return Layout;\n}();\n\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\r\n * be throwing an error) annotated with the property of a given layout\r\n * (such as one for which the value was unacceptable).\r\n *\r\n * @ignore */\n\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n\n  return name;\n}\n\nexports.nameWithProperty = nameWithProperty;\n/**\r\n * Augment a class so that instances can be encoded/decoded using a\r\n * given layout.\r\n *\r\n * Calling this function couples `Class` with `layout` in several ways:\r\n *\r\n * * `Class.layout_` becomes a static member property equal to `layout`;\r\n * * `layout.boundConstructor_` becomes a static member property equal\r\n *    to `Class`;\r\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\r\n *   property of `layout` is set to a function that returns a `new\r\n *   Class()`;\r\n * * `Class.decode(b, offset)` becomes a static member function that\r\n *   delegates to {@link Layout#decode|layout.decode}.  The\r\n *   synthesized function may be captured and extended.\r\n * * `Class.prototype.encode(b, offset)` provides an instance member\r\n *   function that delegates to {@link Layout#encode|layout.encode}\r\n *   with `src` set to `this`.  The synthesized function may be\r\n *   captured and extended, but when the extension is invoked `this`\r\n *   must be explicitly bound to the instance.\r\n *\r\n * @param {class} Class - a JavaScript class with a nullary\r\n * constructor.\r\n *\r\n * @param {Layout} layout - the {@link Layout} instance used to encode\r\n * instances of `Class`.\r\n */\n\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n\n  if (Class.hasOwnProperty('layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n\n  if (!(layout && layout instanceof Layout)) {\n    throw new TypeError('layout must be a Layout');\n  }\n\n  if (layout.hasOwnProperty('boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n\n  layout.makeDestinationObject = function () {\n    return new Class();\n  };\n\n  Object.defineProperty(Class.prototype, 'encode', {\n    value: function value(b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true\n  });\n  Object.defineProperty(Class, 'decode', {\n    value: function value(b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true\n  });\n}\n\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\r\n * An object that behaves like a layout but does not consume space\r\n * within its containing layout.\r\n *\r\n * This is primarily used to obtain metadata about a member, such as a\r\n * {@link OffsetLayout} that can provide data about a {@link\r\n * Layout#getSpan|value-specific span}.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support {@link\r\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @abstract\r\n * @augments {Layout}\r\n */\n\nvar ExternalLayout = /*#__PURE__*/function (_Layout) {\n  _inherits(ExternalLayout, _Layout);\n\n  var _super = _createSuper(ExternalLayout);\n\n  function ExternalLayout() {\n    _classCallCheck(this, ExternalLayout);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ExternalLayout, [{\n    key: \"isCount\",\n    value:\n    /**\r\n     * Return `true` iff the external layout decodes to an unsigned\r\n     * integer layout.\r\n     *\r\n     * In that case it can be used as the source of {@link\r\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\r\n     * or as {@link UnionLayoutDiscriminator#layout|external union\r\n     * discriminators}.\r\n     *\r\n     * @abstract\r\n     */\n    function isCount() {\n      throw new Error('ExternalLayout is abstract');\n    }\n  }]);\n\n  return ExternalLayout;\n}(Layout);\n/**\r\n * An {@link ExternalLayout} that determines its {@link\r\n * Layout#decode|value} based on offset into and length of the buffer\r\n * on which it is invoked.\r\n *\r\n * *Factory*: {@link module:Layout.greedy|greedy}\r\n *\r\n * @param {Number} [elementSpan] - initializer for {@link\r\n * GreedyCount#elementSpan|elementSpan}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {ExternalLayout}\r\n */\n\n\nvar GreedyCount = /*#__PURE__*/function (_ExternalLayout) {\n  _inherits(GreedyCount, _ExternalLayout);\n\n  var _super2 = _createSuper(GreedyCount);\n\n  function GreedyCount(elementSpan, property) {\n    var _this;\n\n    _classCallCheck(this, GreedyCount);\n\n    if (undefined === elementSpan) {\n      elementSpan = 1;\n    }\n\n    if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n\n    _this = _super2.call(this, -1, property);\n    /** The layout for individual elements of the sequence.  The value\r\n     * must be a positive integer.  If not provided, the value will be\r\n     * 1. */\n\n    _this.elementSpan = elementSpan;\n    return _this;\n  }\n  /** @override */\n\n\n  _createClass(GreedyCount, [{\n    key: \"isCount\",\n    value: function isCount() {\n      return true;\n    }\n    /** @override */\n\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var rem = b.length - offset;\n      return Math.floor(rem / this.elementSpan);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      return 0;\n    }\n  }]);\n\n  return GreedyCount;\n}(ExternalLayout);\n/**\r\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\r\n * at a fixed offset from the start of another Layout.  The offset may\r\n * be before, within, or after the base layout.\r\n *\r\n * *Factory*: {@link module:Layout.offset|offset}\r\n *\r\n * @param {Layout} layout - initializer for {@link\r\n * OffsetLayout#layout|layout}, modulo `property`.\r\n *\r\n * @param {Number} [offset] - Initializes {@link\r\n * OffsetLayout#offset|offset}.  Defaults to zero.\r\n *\r\n * @param {string} [property] - Optional new property name for a\r\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\r\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\r\n * unchanged.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar OffsetLayout = /*#__PURE__*/function (_ExternalLayout2) {\n  _inherits(OffsetLayout, _ExternalLayout2);\n\n  var _super3 = _createSuper(OffsetLayout);\n\n  function OffsetLayout(layout, offset, property) {\n    var _this2;\n\n    _classCallCheck(this, OffsetLayout);\n\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n\n    _this2 = _super3.call(this, layout.span, property || layout.property);\n    /** The subordinated layout. */\n\n    _this2.layout = layout;\n    /** The location of {@link OffsetLayout#layout} relative to the\r\n     * start of another layout.\r\n     *\r\n     * The value may be positive or negative, but an error will thrown\r\n     * if at the point of use it goes outside the span of the Buffer\r\n     * being accessed.  */\n\n    _this2.offset = offset;\n    return _this2;\n  }\n  /** @override */\n\n\n  _createClass(OffsetLayout, [{\n    key: \"isCount\",\n    value: function isCount() {\n      return this.layout instanceof UInt || this.layout instanceof UIntBE;\n    }\n    /** @override */\n\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      return this.layout.decode(b, offset + this.offset);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      return this.layout.encode(src, b, offset + this.offset);\n    }\n  }]);\n\n  return OffsetLayout;\n}(ExternalLayout);\n/**\r\n * Represent an unsigned integer in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.u8|u8}, {@link\r\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\r\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\r\n *  module:Layout.u48|u48}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar UInt = /*#__PURE__*/function (_Layout2) {\n  _inherits(UInt, _Layout2);\n\n  var _super4 = _createSuper(UInt);\n\n  function UInt(span, property) {\n    var _this3;\n\n    _classCallCheck(this, UInt);\n\n    _this3 = _super4.call(this, span, property);\n\n    if (6 < _this3.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n\n    return _this3;\n  }\n  /** @override */\n\n\n  _createClass(UInt, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      return b.readUIntLE(offset, this.span);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      b.writeUIntLE(src, offset, this.span);\n      return this.span;\n    }\n  }]);\n\n  return UInt;\n}(Layout);\n/**\r\n * Represent an unsigned integer in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\r\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\r\n * {@link module:Layout.u32be|u32be}, {@link\r\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar UIntBE = /*#__PURE__*/function (_Layout3) {\n  _inherits(UIntBE, _Layout3);\n\n  var _super5 = _createSuper(UIntBE);\n\n  function UIntBE(span, property) {\n    var _this4;\n\n    _classCallCheck(this, UIntBE);\n\n    _this4 = _super5.call(this, span, property);\n\n    if (6 < _this4.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n\n    return _this4;\n  }\n  /** @override */\n\n\n  _createClass(UIntBE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      return b.readUIntBE(offset, this.span);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      b.writeUIntBE(src, offset, this.span);\n      return this.span;\n    }\n  }]);\n\n  return UIntBE;\n}(Layout);\n/**\r\n * Represent a signed integer in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.s8|s8}, {@link\r\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\r\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\r\n *  module:Layout.s48|s48}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar Int = /*#__PURE__*/function (_Layout4) {\n  _inherits(Int, _Layout4);\n\n  var _super6 = _createSuper(Int);\n\n  function Int(span, property) {\n    var _this5;\n\n    _classCallCheck(this, Int);\n\n    _this5 = _super6.call(this, span, property);\n\n    if (6 < _this5.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n\n    return _this5;\n  }\n  /** @override */\n\n\n  _createClass(Int, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      return b.readIntLE(offset, this.span);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      b.writeIntLE(src, offset, this.span);\n      return this.span;\n    }\n  }]);\n\n  return Int;\n}(Layout);\n/**\r\n * Represent a signed integer in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\r\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\r\n * {@link module:Layout.s32be|s32be}, {@link\r\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar IntBE = /*#__PURE__*/function (_Layout5) {\n  _inherits(IntBE, _Layout5);\n\n  var _super7 = _createSuper(IntBE);\n\n  function IntBE(span, property) {\n    var _this6;\n\n    _classCallCheck(this, IntBE);\n\n    _this6 = _super7.call(this, span, property);\n\n    if (6 < _this6.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n\n    return _this6;\n  }\n  /** @override */\n\n\n  _createClass(IntBE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      return b.readIntBE(offset, this.span);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      b.writeIntBE(src, offset, this.span);\n      return this.span;\n    }\n  }]);\n\n  return IntBE;\n}(Layout);\n\nvar V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\r\n * non-negative. */\n\nfunction divmodInt64(src) {\n  var hi32 = Math.floor(src / V2E32);\n  var lo32 = src - hi32 * V2E32;\n  return {\n    hi32: hi32,\n    lo32: lo32\n  };\n}\n/* Reconstruct Number from quotient and non-negative remainder */\n\n\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n/**\r\n * Represent an unsigned 64-bit integer in little-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.nu64|nu64}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar NearUInt64 = /*#__PURE__*/function (_Layout6) {\n  _inherits(NearUInt64, _Layout6);\n\n  var _super8 = _createSuper(NearUInt64);\n\n  function NearUInt64(property) {\n    _classCallCheck(this, NearUInt64);\n\n    return _super8.call(this, 8, property);\n  }\n  /** @override */\n\n\n  _createClass(NearUInt64, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var lo32 = b.readUInt32LE(offset);\n      var hi32 = b.readUInt32LE(offset + 4);\n      return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var split = divmodInt64(src);\n      b.writeUInt32LE(split.lo32, offset);\n      b.writeUInt32LE(split.hi32, offset + 4);\n      return 8;\n    }\n  }]);\n\n  return NearUInt64;\n}(Layout);\n/**\r\n * Represent an unsigned 64-bit integer in big-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.nu64be|nu64be}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar NearUInt64BE = /*#__PURE__*/function (_Layout7) {\n  _inherits(NearUInt64BE, _Layout7);\n\n  var _super9 = _createSuper(NearUInt64BE);\n\n  function NearUInt64BE(property) {\n    _classCallCheck(this, NearUInt64BE);\n\n    return _super9.call(this, 8, property);\n  }\n  /** @override */\n\n\n  _createClass(NearUInt64BE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var hi32 = b.readUInt32BE(offset);\n      var lo32 = b.readUInt32BE(offset + 4);\n      return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var split = divmodInt64(src);\n      b.writeUInt32BE(split.hi32, offset);\n      b.writeUInt32BE(split.lo32, offset + 4);\n      return 8;\n    }\n  }]);\n\n  return NearUInt64BE;\n}(Layout);\n/**\r\n * Represent a signed 64-bit integer in little-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.ns64|ns64}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar NearInt64 = /*#__PURE__*/function (_Layout8) {\n  _inherits(NearInt64, _Layout8);\n\n  var _super10 = _createSuper(NearInt64);\n\n  function NearInt64(property) {\n    _classCallCheck(this, NearInt64);\n\n    return _super10.call(this, 8, property);\n  }\n  /** @override */\n\n\n  _createClass(NearInt64, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var lo32 = b.readUInt32LE(offset);\n      var hi32 = b.readInt32LE(offset + 4);\n      return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var split = divmodInt64(src);\n      b.writeUInt32LE(split.lo32, offset);\n      b.writeInt32LE(split.hi32, offset + 4);\n      return 8;\n    }\n  }]);\n\n  return NearInt64;\n}(Layout);\n/**\r\n * Represent a signed 64-bit integer in big-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.ns64be|ns64be}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar NearInt64BE = /*#__PURE__*/function (_Layout9) {\n  _inherits(NearInt64BE, _Layout9);\n\n  var _super11 = _createSuper(NearInt64BE);\n\n  function NearInt64BE(property) {\n    _classCallCheck(this, NearInt64BE);\n\n    return _super11.call(this, 8, property);\n  }\n  /** @override */\n\n\n  _createClass(NearInt64BE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var hi32 = b.readInt32BE(offset);\n      var lo32 = b.readUInt32BE(offset + 4);\n      return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var split = divmodInt64(src);\n      b.writeInt32BE(split.hi32, offset);\n      b.writeUInt32BE(split.lo32, offset + 4);\n      return 8;\n    }\n  }]);\n\n  return NearInt64BE;\n}(Layout);\n/**\r\n * Represent a 32-bit floating point number in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f32|f32}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar Float = /*#__PURE__*/function (_Layout10) {\n  _inherits(Float, _Layout10);\n\n  var _super12 = _createSuper(Float);\n\n  function Float(property) {\n    _classCallCheck(this, Float);\n\n    return _super12.call(this, 4, property);\n  }\n  /** @override */\n\n\n  _createClass(Float, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      return b.readFloatLE(offset);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      b.writeFloatLE(src, offset);\n      return 4;\n    }\n  }]);\n\n  return Float;\n}(Layout);\n/**\r\n * Represent a 32-bit floating point number in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f32be|f32be}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar FloatBE = /*#__PURE__*/function (_Layout11) {\n  _inherits(FloatBE, _Layout11);\n\n  var _super13 = _createSuper(FloatBE);\n\n  function FloatBE(property) {\n    _classCallCheck(this, FloatBE);\n\n    return _super13.call(this, 4, property);\n  }\n  /** @override */\n\n\n  _createClass(FloatBE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      return b.readFloatBE(offset);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      b.writeFloatBE(src, offset);\n      return 4;\n    }\n  }]);\n\n  return FloatBE;\n}(Layout);\n/**\r\n * Represent a 64-bit floating point number in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f64|f64}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar Double = /*#__PURE__*/function (_Layout12) {\n  _inherits(Double, _Layout12);\n\n  var _super14 = _createSuper(Double);\n\n  function Double(property) {\n    _classCallCheck(this, Double);\n\n    return _super14.call(this, 8, property);\n  }\n  /** @override */\n\n\n  _createClass(Double, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      return b.readDoubleLE(offset);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      b.writeDoubleLE(src, offset);\n      return 8;\n    }\n  }]);\n\n  return Double;\n}(Layout);\n/**\r\n * Represent a 64-bit floating point number in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f64be|f64be}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar DoubleBE = /*#__PURE__*/function (_Layout13) {\n  _inherits(DoubleBE, _Layout13);\n\n  var _super15 = _createSuper(DoubleBE);\n\n  function DoubleBE(property) {\n    _classCallCheck(this, DoubleBE);\n\n    return _super15.call(this, 8, property);\n  }\n  /** @override */\n\n\n  _createClass(DoubleBE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      return b.readDoubleBE(offset);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      b.writeDoubleBE(src, offset);\n      return 8;\n    }\n  }]);\n\n  return DoubleBE;\n}(Layout);\n/**\r\n * Represent a contiguous sequence of a specific layout as an Array.\r\n *\r\n * *Factory*: {@link module:Layout.seq|seq}\r\n *\r\n * @param {Layout} elementLayout - initializer for {@link\r\n * Sequence#elementLayout|elementLayout}.\r\n *\r\n * @param {(Number|ExternalLayout)} count - initializer for {@link\r\n * Sequence#count|count}.  The parameter must be either a positive\r\n * integer or an instance of {@link ExternalLayout}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar Sequence = /*#__PURE__*/function (_Layout14) {\n  _inherits(Sequence, _Layout14);\n\n  var _super16 = _createSuper(Sequence);\n\n  function Sequence(elementLayout, count, property) {\n    var _this7;\n\n    _classCallCheck(this, Sequence);\n\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n\n    if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n      throw new TypeError('count must be non-negative integer ' + 'or an unsigned integer ExternalLayout');\n    }\n\n    var span = -1;\n\n    if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n      span = count * elementLayout.span;\n    }\n\n    _this7 = _super16.call(this, span, property);\n    /** The layout for individual elements of the sequence. */\n\n    _this7.elementLayout = elementLayout;\n    /** The number of elements in the sequence.\r\n     *\r\n     * This will be either a non-negative integer or an instance of\r\n     * {@link ExternalLayout} for which {@link\r\n     * ExternalLayout#isCount|isCount()} is `true`. */\n\n    _this7.count = count;\n    return _this7;\n  }\n  /** @override */\n\n\n  _createClass(Sequence, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 <= this.span) {\n        return this.span;\n      }\n\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var span = 0;\n      var count = this.count;\n\n      if (count instanceof ExternalLayout) {\n        count = count.decode(b, offset);\n      }\n\n      if (0 < this.elementLayout.span) {\n        span = count * this.elementLayout.span;\n      } else {\n        var idx = 0;\n\n        while (idx < count) {\n          span += this.elementLayout.getSpan(b, offset + span);\n          ++idx;\n        }\n      }\n\n      return span;\n    }\n    /** @override */\n\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var rv = [];\n      var i = 0;\n      var count = this.count;\n\n      if (count instanceof ExternalLayout) {\n        count = count.decode(b, offset);\n      }\n\n      while (i < count) {\n        rv.push(this.elementLayout.decode(b, offset));\n        offset += this.elementLayout.getSpan(b, offset);\n        i += 1;\n      }\n\n      return rv;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\r\n     *\r\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\r\n     * the unused space in the buffer is left unchanged.  If `src` is\r\n     * longer than {@link Sequence#count|count} the unneeded elements are\r\n     * ignored.\r\n     *\r\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\r\n     * ExternalLayout} then the length of `src` will be encoded as the\r\n     * count after `src` is encoded. */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var elo = this.elementLayout;\n      var span = src.reduce(function (span, v) {\n        return span + elo.encode(v, b, offset + span);\n      }, 0);\n\n      if (this.count instanceof ExternalLayout) {\n        this.count.encode(src.length, b, offset);\n      }\n\n      return span;\n    }\n  }]);\n\n  return Sequence;\n}(Layout);\n/**\r\n * Represent a contiguous sequence of arbitrary layout elements as an\r\n * Object.\r\n *\r\n * *Factory*: {@link module:Layout.struct|struct}\r\n *\r\n * **NOTE** The {@link Layout#span|span} of the structure is variable\r\n * if any layout in {@link Structure#fields|fields} has a variable\r\n * span.  When {@link Layout#encode|encoding} we must have a value for\r\n * all variable-length fields, or we wouldn't be able to figure out\r\n * how much space to use for storage.  We can only identify the value\r\n * for a field when it has a {@link Layout#property|property}.  As\r\n * such, although a structure may contain both unnamed fields and\r\n * variable-length fields, it cannot contain an unnamed\r\n * variable-length field.\r\n *\r\n * @param {Layout[]} fields - initializer for {@link\r\n * Structure#fields|fields}.  An error is raised if this contains a\r\n * variable-length field for which a {@link Layout#property|property}\r\n * is not defined.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @param {Boolean} [decodePrefixes] - initializer for {@link\r\n * Structure#decodePrefixes|property}.\r\n *\r\n * @throws {Error} - if `fields` contains an unnamed variable-length\r\n * layout.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar Structure = /*#__PURE__*/function (_Layout15) {\n  _inherits(Structure, _Layout15);\n\n  var _super17 = _createSuper(Structure);\n\n  function Structure(fields, property, decodePrefixes) {\n    var _this8;\n\n    _classCallCheck(this, Structure);\n\n    if (!(Array.isArray(fields) && fields.reduce(function (acc, v) {\n      return acc && v instanceof Layout;\n    }, true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n\n    if ('boolean' === typeof property && undefined === decodePrefixes) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n    /* Verify absence of unnamed variable-length fields. */\n\n\n    var _iterator = _createForOfIteratorHelper(fields),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var fd = _step.value;\n\n        if (0 > fd.span && undefined === fd.property) {\n          throw new Error('fields cannot contain unnamed variable-length layout');\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var span = -1;\n\n    try {\n      span = fields.reduce(function (span, fd) {\n        return span + fd.getSpan();\n      }, 0);\n    } catch (e) {}\n\n    _this8 = _super17.call(this, span, property);\n    /** The sequence of {@link Layout} values that comprise the\r\n     * structure.\r\n     *\r\n     * The individual elements need not be the same type, and may be\r\n     * either scalar or aggregate layouts.  If a member layout leaves\r\n     * its {@link Layout#property|property} undefined the\r\n     * corresponding region of the buffer associated with the element\r\n     * will not be mutated.\r\n     *\r\n     * @type {Layout[]} */\n\n    _this8.fields = fields;\n    /** Control behavior of {@link Layout#decode|decode()} given short\r\n     * buffers.\r\n     *\r\n     * In some situations a structure many be extended with additional\r\n     * fields over time, with older installations providing only a\r\n     * prefix of the full structure.  If this property is `true`\r\n     * decoding will accept those buffers and leave subsequent fields\r\n     * undefined, as long as the buffer ends at a field boundary.\r\n     * Defaults to `false`. */\n\n    _this8.decodePrefixes = !!decodePrefixes;\n    return _this8;\n  }\n  /** @override */\n\n\n  _createClass(Structure, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 <= this.span) {\n        return this.span;\n      }\n\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var span = 0;\n\n      try {\n        span = this.fields.reduce(function (span, fd) {\n          var fsp = fd.getSpan(b, offset);\n          offset += fsp;\n          return span + fsp;\n        }, 0);\n      } catch (e) {\n        throw new RangeError('indeterminate span');\n      }\n\n      return span;\n    }\n    /** @override */\n\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var dest = this.makeDestinationObject();\n\n      var _iterator2 = _createForOfIteratorHelper(this.fields),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var fd = _step2.value;\n\n          if (undefined !== fd.property) {\n            dest[fd.property] = fd.decode(b, offset);\n          }\n\n          offset += fd.getSpan(b, offset);\n\n          if (this.decodePrefixes && b.length === offset) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\r\n     *\r\n     * If `src` is missing a property for a member with a defined {@link\r\n     * Layout#property|property} the corresponding region of the buffer is\r\n     * left unmodified. */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var firstOffset = offset;\n      var lastOffset = 0;\n      var lastWrote = 0;\n\n      var _iterator3 = _createForOfIteratorHelper(this.fields),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var fd = _step3.value;\n          var span = fd.span;\n          lastWrote = 0 < span ? span : 0;\n\n          if (undefined !== fd.property) {\n            var fv = src[fd.property];\n\n            if (undefined !== fv) {\n              lastWrote = fd.encode(fv, b, offset);\n\n              if (0 > span) {\n                /* Read the as-encoded span, which is not necessarily the\r\n                 * same as what we wrote. */\n                span = fd.getSpan(b, offset);\n              }\n            }\n          }\n\n          lastOffset = offset;\n          offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\r\n         * item may have had a dynamic length and we don't want to include\r\n         * the padding between it and the end of the space reserved for\r\n         * it. */\n\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return lastOffset + lastWrote - firstOffset;\n    }\n    /** @override */\n\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(values) {\n      var dest = this.makeDestinationObject();\n\n      var _iterator4 = _createForOfIteratorHelper(this.fields),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var fd = _step4.value;\n\n          if (undefined !== fd.property && 0 < values.length) {\n            dest[fd.property] = values.shift();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return dest;\n    }\n    /**\r\n     * Get access to the layout of a given property.\r\n     *\r\n     * @param {String} property - the structure member of interest.\r\n     *\r\n     * @return {Layout} - the layout associated with `property`, or\r\n     * undefined if there is no such property.\r\n     */\n\n  }, {\n    key: \"layoutFor\",\n    value: function layoutFor(property) {\n      if ('string' !== typeof property) {\n        throw new TypeError('property must be string');\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(this.fields),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var fd = _step5.value;\n\n          if (fd.property === property) {\n            return fd;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n    /**\r\n     * Get the offset of a structure member.\r\n     *\r\n     * @param {String} property - the structure member of interest.\r\n     *\r\n     * @return {Number} - the offset in bytes to the start of `property`\r\n     * within the structure, or undefined if `property` is not a field\r\n     * within the structure.  If the property is a member but follows a\r\n     * variable-length structure member a negative number will be\r\n     * returned.\r\n     */\n\n  }, {\n    key: \"offsetOf\",\n    value: function offsetOf(property) {\n      if ('string' !== typeof property) {\n        throw new TypeError('property must be string');\n      }\n\n      var offset = 0;\n\n      var _iterator6 = _createForOfIteratorHelper(this.fields),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var fd = _step6.value;\n\n          if (fd.property === property) {\n            return offset;\n          }\n\n          if (0 > fd.span) {\n            offset = -1;\n          } else if (0 <= offset) {\n            offset += fd.span;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }]);\n\n  return Structure;\n}(Layout);\n/**\r\n * An object that can provide a {@link\r\n * Union#discriminator|discriminator} API for {@link Union}.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support the {@link\r\n * UnionDiscriminator#encode|encode} or {@link\r\n * UnionDiscriminator#decode|decode} functions.\r\n *\r\n * @param {string} [property] - Default for {@link\r\n * UnionDiscriminator#property|property}.\r\n *\r\n * @abstract\r\n */\n\n\nvar UnionDiscriminator = /*#__PURE__*/function () {\n  function UnionDiscriminator(property) {\n    _classCallCheck(this, UnionDiscriminator);\n\n    /** The {@link Layout#property|property} to be used when the\r\n     * discriminator is referenced in isolation (generally when {@link\r\n     * Union#decode|Union decode} cannot delegate to a specific\r\n     * variant). */\n    this.property = property;\n  }\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\r\n   *\r\n   * The implementation of this method need not reference the buffer if\r\n   * variant information is available through other means. */\n\n\n  _createClass(UnionDiscriminator, [{\n    key: \"decode\",\n    value: function decode() {\n      throw new Error('UnionDiscriminator is abstract');\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\r\n     *\r\n     * The implementation of this method need not store the value if\r\n     * variant information is maintained through other means. */\n\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      throw new Error('UnionDiscriminator is abstract');\n    }\n  }]);\n\n  return UnionDiscriminator;\n}();\n/**\r\n * An object that can provide a {@link\r\n * UnionDiscriminator|discriminator API} for {@link Union} using an\r\n * unsigned integral {@link Layout} instance located either inside or\r\n * outside the union.\r\n *\r\n * @param {ExternalLayout} layout - initializes {@link\r\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\r\n * ExternalLayout#isCount|isCount()}.\r\n *\r\n * @param {string} [property] - Default for {@link\r\n * UnionDiscriminator#property|property}, superseding the property\r\n * from `layout`, but defaulting to `variant` if neither `property`\r\n * nor layout provide a property name.\r\n *\r\n * @augments {UnionDiscriminator}\r\n */\n\n\nvar UnionLayoutDiscriminator = /*#__PURE__*/function (_UnionDiscriminator) {\n  _inherits(UnionLayoutDiscriminator, _UnionDiscriminator);\n\n  var _super18 = _createSuper(UnionLayoutDiscriminator);\n\n  function UnionLayoutDiscriminator(layout, property) {\n    var _this9;\n\n    _classCallCheck(this, UnionLayoutDiscriminator);\n\n    if (!(layout instanceof ExternalLayout && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n\n    _this9 = _super18.call(this, property || layout.property || 'variant');\n    /** The {@link ExternalLayout} used to access the discriminator\r\n     * value. */\n\n    _this9.layout = layout;\n    return _this9;\n  }\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n\n\n  _createClass(UnionLayoutDiscriminator, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      return this.layout.decode(b, offset);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      return this.layout.encode(src, b, offset);\n    }\n  }]);\n\n  return UnionLayoutDiscriminator;\n}(UnionDiscriminator);\n/**\r\n * Represent any number of span-compatible layouts.\r\n *\r\n * *Factory*: {@link module:Layout.union|union}\r\n *\r\n * If the union has a {@link Union#defaultLayout|default layout} that\r\n * layout must have a non-negative {@link Layout#span|span}.  The span\r\n * of a fixed-span union includes its {@link\r\n * Union#discriminator|discriminator} if the variant is a {@link\r\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\r\n * of its {@link Union#defaultLayout|default layout}.\r\n *\r\n * If the union does not have a default layout then the encoded span\r\n * of the union depends on the encoded span of its variant (which may\r\n * be fixed or variable).\r\n *\r\n * {@link VariantLayout#layout|Variant layout}s are added through\r\n * {@link Union#addVariant|addVariant}.  If the union has a default\r\n * layout, the span of the {@link VariantLayout#layout|layout\r\n * contained by the variant} must not exceed the span of the {@link\r\n * Union#defaultLayout|default layout} (minus the span of a {@link\r\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\r\n * span of the variant will equal the span of the union itself.\r\n *\r\n * The variant for a buffer can only be identified from the {@link\r\n * Union#discriminator|discriminator} {@link\r\n * UnionDiscriminator#property|property} (in the case of the {@link\r\n * Union#defaultLayout|default layout}), or by using {@link\r\n * Union#getVariant|getVariant} and examining the resulting {@link\r\n * VariantLayout} instance.\r\n *\r\n * A variant compatible with a JavaScript object can be identified\r\n * using {@link Union#getSourceVariant|getSourceVariant}.\r\n *\r\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\r\n * identify the layout used to interpret the union contents.  The\r\n * parameter must be an instance of {@link UnionDiscriminator}, an\r\n * {@link ExternalLayout} that satisfies {@link\r\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\r\n * UIntBE}).  When a non-external layout element is passed the layout\r\n * appears at the start of the union.  In all cases the (synthesized)\r\n * {@link UnionDiscriminator} instance is recorded as {@link\r\n * Union#discriminator|discriminator}.\r\n *\r\n * @param {(Layout|null)} defaultLayout - initializer for {@link\r\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\r\n * If `null` there is no default layout: the union has data-dependent\r\n * length and attempts to decode or encode unrecognized variants will\r\n * throw an exception.  A {@link Layout} instance must have a\r\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\r\n * Layout#property|property} the {@link\r\n * Union#defaultLayout|defaultLayout} will be a {@link\r\n * Layout#replicate|replica} with property `content`.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar Union = /*#__PURE__*/function (_Layout16) {\n  _inherits(Union, _Layout16);\n\n  var _super19 = _createSuper(Union);\n\n  function Union(discr, defaultLayout, property) {\n    var _this10;\n\n    _classCallCheck(this, Union);\n\n    var upv = discr instanceof UInt || discr instanceof UIntBE;\n\n    if (upv) {\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if (discr instanceof ExternalLayout && discr.isCount()) {\n      discr = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator ' + 'or an unsigned integer layout');\n    }\n\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n\n    if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n    /* The union span can be estimated only if there's a default\r\n     * layout.  The union spans its default layout, plus any prefix\r\n     * variant layout.  By construction both layouts, if present, have\r\n     * non-negative span. */\n\n\n    var span = -1;\n\n    if (defaultLayout) {\n      span = defaultLayout.span;\n\n      if (0 <= span && upv) {\n        span += discr.layout.span;\n      }\n    }\n\n    _this10 = _super19.call(this, span, property);\n    /** The interface for the discriminator value in isolation.\r\n     *\r\n     * This a {@link UnionDiscriminator} either passed to the\r\n     * constructor or synthesized from the `discr` constructor\r\n     * argument.  {@link\r\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\r\n     * `true` iff the `discr` parameter was a non-offset {@link\r\n     * Layout} instance. */\n\n    _this10.discriminator = discr;\n    /** `true` if the {@link Union#discriminator|discriminator} is the\r\n     * first field in the union.\r\n     *\r\n     * If `false` the discriminator is obtained from somewhere\r\n     * else. */\n\n    _this10.usesPrefixDiscriminator = upv;\n    /** The layout for non-discriminator content when the value of the\r\n     * discriminator is not recognized.\r\n     *\r\n     * This is the value passed to the constructor.  It is\r\n     * structurally equivalent to the second component of {@link\r\n     * Union#layout|layout} but may have a different property\r\n     * name. */\n\n    _this10.defaultLayout = defaultLayout;\n    /** A registry of allowed variants.\r\n     *\r\n     * The keys are unsigned integers which should be compatible with\r\n     * {@link Union.discriminator|discriminator}.  The property value\r\n     * is the corresponding {@link VariantLayout} instances assigned\r\n     * to this union by {@link Union#addVariant|addVariant}.\r\n     *\r\n     * **NOTE** The registry remains mutable so that variants can be\r\n     * {@link Union#addVariant|added} at any time.  Users should not\r\n     * manipulate the content of this property. */\n\n    _this10.registry = {};\n    /* Private variable used when invoking getSourceVariant */\n\n    var boundGetSourceVariant = _this10.defaultGetSourceVariant.bind(_assertThisInitialized(_this10));\n    /** Function to infer the variant selected by a source object.\r\n     *\r\n     * Defaults to {@link\r\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\r\n     * be overridden using {@link\r\n     * Union#configGetSourceVariant|configGetSourceVariant}.\r\n     *\r\n     * @param {Object} src - as with {@link\r\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\r\n     *\r\n     * @returns {(undefined|VariantLayout)} The default variant\r\n     * (`undefined`) or first registered variant that uses a property\r\n     * available in `src`. */\n\n\n    _this10.getSourceVariant = function (src) {\n      return boundGetSourceVariant(src);\n    };\n    /** Function to override the implementation of {@link\r\n     * Union#getSourceVariant|getSourceVariant}.\r\n     *\r\n     * Use this if the desired variant cannot be identified using the\r\n     * algorithm of {@link\r\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\r\n     *\r\n     * **NOTE** The provided function will be invoked bound to this\r\n     * Union instance, providing local access to {@link\r\n     * Union#registry|registry}.\r\n     *\r\n     * @param {Function} gsv - a function that follows the API of\r\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n\n\n    _this10.configGetSourceVariant = function (gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n\n    return _this10;\n  }\n  /** @override */\n\n\n  _createClass(Union, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 <= this.span) {\n        return this.span;\n      }\n\n      if (undefined === offset) {\n        offset = 0;\n      }\n      /* Default layouts always have non-negative span, so we don't have\r\n       * one and we have to recognize the variant which will in turn\r\n       * determine the span. */\n\n\n      var vlo = this.getVariant(b, offset);\n\n      if (!vlo) {\n        throw new Error('unable to determine span for unrecognized variant');\n      }\n\n      return vlo.getSpan(b, offset);\n    }\n    /**\r\n     * Method to infer a registered Union variant compatible with `src`.\r\n     *\r\n     * The first satisified rule in the following sequence defines the\r\n     * return value:\r\n     * * If `src` has properties matching the Union discriminator and\r\n     *   the default layout, `undefined` is returned regardless of the\r\n     *   value of the discriminator property (this ensures the default\r\n     *   layout will be used);\r\n     * * If `src` has a property matching the Union discriminator, the\r\n     *   value of the discriminator identifies a registered variant, and\r\n     *   either (a) the variant has no layout, or (b) `src` has the\r\n     *   variant's property, then the variant is returned (because the\r\n     *   source satisfies the constraints of the variant it identifies);\r\n     * * If `src` does not have a property matching the Union\r\n     *   discriminator, but does have a property matching a registered\r\n     *   variant, then the variant is returned (because the source\r\n     *   matches a variant without an explicit conflict);\r\n     * * An error is thrown (because we either can't identify a variant,\r\n     *   or we were explicitly told the variant but can't satisfy it).\r\n     *\r\n     * @param {Object} src - an object presumed to be compatible with\r\n     * the content of the Union.\r\n     *\r\n     * @return {(undefined|VariantLayout)} - as described above.\r\n     *\r\n     * @throws {Error} - if `src` cannot be associated with a default or\r\n     * registered variant.\r\n     */\n\n  }, {\n    key: \"defaultGetSourceVariant\",\n    value: function defaultGetSourceVariant(src) {\n      if (src.hasOwnProperty(this.discriminator.property)) {\n        if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {\n          return undefined;\n        }\n\n        var vlo = this.registry[src[this.discriminator.property]];\n\n        if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {\n          return vlo;\n        }\n      } else {\n        for (var tag in this.registry) {\n          var _vlo = this.registry[tag];\n\n          if (src.hasOwnProperty(_vlo.property)) {\n            return _vlo;\n          }\n        }\n      }\n\n      throw new Error('unable to infer src variant');\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\r\n     *\r\n     * If the variant is {@link Union#addVariant|registered} the return\r\n     * value is an instance of that variant, with no explicit\r\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\r\n     * layout} is used to decode the content. */\n\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var dest;\n      var dlo = this.discriminator;\n      var discr = dlo.decode(b, offset);\n      var clo = this.registry[discr];\n\n      if (undefined === clo) {\n        var contentOffset = 0;\n        clo = this.defaultLayout;\n\n        if (this.usesPrefixDiscriminator) {\n          contentOffset = dlo.layout.span;\n        }\n\n        dest = this.makeDestinationObject();\n        dest[dlo.property] = discr;\n        dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n      } else {\n        dest = clo.decode(b, offset);\n      }\n\n      return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\r\n     *\r\n     * This API assumes the `src` object is consistent with the union's\r\n     * {@link Union#defaultLayout|default layout}.  To encode variants\r\n     * use the appropriate variant-specific {@link VariantLayout#encode}\r\n     * method. */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var vlo = this.getSourceVariant(src);\n\n      if (undefined === vlo) {\n        var dlo = this.discriminator;\n        var clo = this.defaultLayout;\n        var contentOffset = 0;\n\n        if (this.usesPrefixDiscriminator) {\n          contentOffset = dlo.layout.span;\n        }\n\n        dlo.encode(src[dlo.property], b, offset);\n        return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n      }\n\n      return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\r\n     * created variant is returned.\r\n     *\r\n     * @param {Number} variant - initializer for {@link\r\n     * VariantLayout#variant|variant}.\r\n     *\r\n     * @param {Layout} layout - initializer for {@link\r\n     * VariantLayout#layout|layout}.\r\n     *\r\n     * @param {String} property - initializer for {@link\r\n     * Layout#property|property}.\r\n     *\r\n     * @return {VariantLayout} */\n\n  }, {\n    key: \"addVariant\",\n    value: function addVariant(variant, layout, property) {\n      var rv = new VariantLayout(this, variant, layout, property);\n      this.registry[variant] = rv;\n      return rv;\n    }\n    /**\r\n     * Get the layout associated with a registered variant.\r\n     *\r\n     * If `vb` does not produce a registered variant the function returns\r\n     * `undefined`.\r\n     *\r\n     * @param {(Number|Buffer)} vb - either the variant number, or a\r\n     * buffer from which the discriminator is to be read.\r\n     *\r\n     * @param {Number} offset - offset into `vb` for the start of the\r\n     * union.  Used only when `vb` is an instance of {Buffer}.\r\n     *\r\n     * @return {({VariantLayout}|undefined)}\r\n     */\n\n  }, {\n    key: \"getVariant\",\n    value: function getVariant(vb, offset) {\n      var variant = vb;\n\n      if (Buffer.isBuffer(vb)) {\n        if (undefined === offset) {\n          offset = 0;\n        }\n\n        variant = this.discriminator.decode(vb, offset);\n      }\n\n      return this.registry[variant];\n    }\n  }]);\n\n  return Union;\n}(Layout);\n/**\r\n * Represent a specific variant within a containing union.\r\n *\r\n * **NOTE** The {@link Layout#span|span} of the variant may include\r\n * the span of the {@link Union#discriminator|discriminator} used to\r\n * identify it, but values read and written using the variant strictly\r\n * conform to the content of {@link VariantLayout#layout|layout}.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.  Use\r\n * the union {@link Union#addVariant|addVariant} helper method.\r\n *\r\n * @param {Union} union - initializer for {@link\r\n * VariantLayout#union|union}.\r\n *\r\n * @param {Number} variant - initializer for {@link\r\n * VariantLayout#variant|variant}.\r\n *\r\n * @param {Layout} [layout] - initializer for {@link\r\n * VariantLayout#layout|layout}.  If absent the variant carries no\r\n * data.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.  Unlike many other layouts, variant\r\n * layouts normally include a property name so they can be identified\r\n * within their containing {@link Union}.  The property identifier may\r\n * be absent only if `layout` is is absent.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar VariantLayout = /*#__PURE__*/function (_Layout17) {\n  _inherits(VariantLayout, _Layout17);\n\n  var _super20 = _createSuper(VariantLayout);\n\n  function VariantLayout(union, variant, layout, property) {\n    var _this11;\n\n    _classCallCheck(this, VariantLayout);\n\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n\n    if (!Number.isInteger(variant) || 0 > variant) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n\n    if ('string' === typeof layout && undefined === property) {\n      property = layout;\n      layout = null;\n    }\n\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n\n      if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n\n    var span = union.span;\n\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n\n      if (0 <= span && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n\n    _this11 = _super20.call(this, span, property);\n    /** The {@link Union} to which this variant belongs. */\n\n    _this11.union = union;\n    /** The unsigned integral value identifying this variant within\r\n     * the {@link Union#discriminator|discriminator} of the containing\r\n     * union. */\n\n    _this11.variant = variant;\n    /** The {@link Layout} to be used when reading/writing the\r\n     * non-discriminator part of the {@link\r\n     * VariantLayout#union|union}.  If `null` the variant carries no\r\n     * data. */\n\n    _this11.layout = layout || null;\n    return _this11;\n  }\n  /** @override */\n\n\n  _createClass(VariantLayout, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 <= this.span) {\n        /* Will be equal to the containing union span if that is not\r\n         * variable. */\n        return this.span;\n      }\n\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var contentOffset = 0;\n\n      if (this.union.usesPrefixDiscriminator) {\n        contentOffset = this.union.discriminator.layout.span;\n      }\n      /* Span is defined solely by the variant (and prefix discriminator) */\n\n\n      return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n    }\n    /** @override */\n\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      var dest = this.makeDestinationObject();\n\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      if (this !== this.union.getVariant(b, offset)) {\n        throw new Error('variant mismatch');\n      }\n\n      var contentOffset = 0;\n\n      if (this.union.usesPrefixDiscriminator) {\n        contentOffset = this.union.discriminator.layout.span;\n      }\n\n      if (this.layout) {\n        dest[this.property] = this.layout.decode(b, offset + contentOffset);\n      } else if (this.property) {\n        dest[this.property] = true;\n      } else if (this.union.usesPrefixDiscriminator) {\n        dest[this.union.discriminator.property] = this.variant;\n      }\n\n      return dest;\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var contentOffset = 0;\n\n      if (this.union.usesPrefixDiscriminator) {\n        contentOffset = this.union.discriminator.layout.span;\n      }\n\n      if (this.layout && !src.hasOwnProperty(this.property)) {\n        throw new TypeError('variant lacks property ' + this.property);\n      }\n\n      this.union.discriminator.encode(this.variant, b, offset);\n      var span = contentOffset;\n\n      if (this.layout) {\n        this.layout.encode(src[this.property], b, offset + contentOffset);\n        span += this.layout.getSpan(b, offset + contentOffset);\n\n        if (0 <= this.union.span && span > this.union.span) {\n          throw new Error('encoded variant overruns containing union');\n        }\n      }\n\n      return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\r\n     * VariantLayout#layout|layout}. */\n\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(values) {\n      if (this.layout) {\n        return this.layout.fromArray(values);\n      }\n    }\n  }]);\n\n  return VariantLayout;\n}(Layout);\n/** JavaScript chose to define bitwise operations as operating on\r\n * signed 32-bit values in 2's complement form, meaning any integer\r\n * with bit 31 set is going to look negative.  For right shifts that's\r\n * not a problem, because `>>>` is a logical shift, but for every\r\n * other bitwise operator we have to compensate for possible negative\r\n * results. */\n\n\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n\n  return v;\n}\n/**\r\n * Contain a sequence of bit fields as an unsigned integer.\r\n *\r\n * *Factory*: {@link module:Layout.bits|bits}\r\n *\r\n * This is a container element; within it there are {@link BitField}\r\n * instances that provide the extracted properties.  The container\r\n * simply defines the aggregate representation and its bit ordering.\r\n * The representation is an object containing properties with numeric\r\n * or {@link Boolean} values.\r\n *\r\n * {@link BitField}s are added with the {@link\r\n * BitStructure#addField|addField} and {@link\r\n * BitStructure#addBoolean|addBoolean} methods.\r\n\r\n * @param {Layout} word - initializer for {@link\r\n * BitStructure#word|word}.  The parameter must be an instance of\r\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\r\n *\r\n * @param {bool} [msb] - `true` if the bit numbering starts at the\r\n * most significant bit of the containing word; `false` (default) if\r\n * it starts at the least significant bit of the containing word.  If\r\n * the parameter at this position is a string and `property` is\r\n * `undefined` the value of this argument will instead be used as the\r\n * value of `property`.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar BitStructure = /*#__PURE__*/function (_Layout18) {\n  _inherits(BitStructure, _Layout18);\n\n  var _super21 = _createSuper(BitStructure);\n\n  function BitStructure(word, msb, property) {\n    var _this12;\n\n    _classCallCheck(this, BitStructure);\n\n    if (!(word instanceof UInt || word instanceof UIntBE)) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n\n    if ('string' === typeof msb && undefined === property) {\n      property = msb;\n      msb = undefined;\n    }\n\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n\n    _this12 = _super21.call(this, word.span, property);\n    /** The layout used for the packed value.  {@link BitField}\r\n     * instances are packed sequentially depending on {@link\r\n     * BitStructure#msb|msb}. */\n\n    _this12.word = word;\n    /** Whether the bit sequences are packed starting at the most\r\n     * significant bit growing down (`true`), or the least significant\r\n     * bit growing up (`false`).\r\n     *\r\n     * **NOTE** Regardless of this value, the least significant bit of\r\n     * any {@link BitField} value is the least significant bit of the\r\n     * corresponding section of the packed value. */\n\n    _this12.msb = !!msb;\n    /** The sequence of {@link BitField} layouts that comprise the\r\n     * packed structure.\r\n     *\r\n     * **NOTE** The array remains mutable to allow fields to be {@link\r\n     * BitStructure#addField|added} after construction.  Users should\r\n     * not manipulate the content of this property.*/\n\n    _this12.fields = [];\n    /* Storage for the value.  Capture a variable instead of using an\r\n     * instance property because we don't want anything to change the\r\n     * value without going through the mutator. */\n\n    var value = 0;\n\n    _this12._packedSetValue = function (v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n\n    _this12._packedGetValue = function () {\n      return value;\n    };\n\n    return _this12;\n  }\n  /** @override */\n\n\n  _createClass(BitStructure, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      var dest = this.makeDestinationObject();\n\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var value = this.word.decode(b, offset);\n\n      this._packedSetValue(value);\n\n      var _iterator7 = _createForOfIteratorHelper(this.fields),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var fd = _step7.value;\n\n          if (undefined !== fd.property) {\n            dest[fd.property] = fd.decode(value);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\r\n     *\r\n     * If `src` is missing a property for a member with a defined {@link\r\n     * Layout#property|property} the corresponding region of the packed\r\n     * value is left unmodified.  Unused bits are also left unmodified. */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var value = this.word.decode(b, offset);\n\n      this._packedSetValue(value);\n\n      var _iterator8 = _createForOfIteratorHelper(this.fields),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var fd = _step8.value;\n\n          if (undefined !== fd.property) {\n            var fv = src[fd.property];\n\n            if (undefined !== fv) {\n              fd.encode(fv);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return this.word.encode(this._packedGetValue(), b, offset);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\r\n     * resulting bitfield is returned.\r\n     *\r\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\r\n     *\r\n     * @param {string} property - initializer for {@link\r\n     * Layout#property|property}.\r\n     *\r\n     * @return {BitField} */\n\n  }, {\n    key: \"addField\",\n    value: function addField(bits, property) {\n      var bf = new BitField(this, bits, property);\n      this.fields.push(bf);\n      return bf;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\r\n     * fields with `boolean` value representation.\r\n     *\r\n     * @param {string} property - initializer for {@link\r\n     * Layout#property|property}.\r\n     *\r\n     * @return {Boolean} */\n\n  }, {\n    key: \"addBoolean\",\n    value: function addBoolean(property) {\n      // This is my Boolean, not the Javascript one.\n      // eslint-disable-next-line no-new-wrappers\n      var bf = new Boolean(this, property);\n      this.fields.push(bf);\n      return bf;\n    }\n    /**\r\n     * Get access to the bit field for a given property.\r\n     *\r\n     * @param {String} property - the bit field of interest.\r\n     *\r\n     * @return {BitField} - the field associated with `property`, or\r\n     * undefined if there is no such property.\r\n     */\n\n  }, {\n    key: \"fieldFor\",\n    value: function fieldFor(property) {\n      if ('string' !== typeof property) {\n        throw new TypeError('property must be string');\n      }\n\n      var _iterator9 = _createForOfIteratorHelper(this.fields),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var fd = _step9.value;\n\n          if (fd.property === property) {\n            return fd;\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  }]);\n\n  return BitStructure;\n}(Layout);\n/**\r\n * Represent a sequence of bits within a {@link BitStructure}.\r\n *\r\n * All bit field values are represented as unsigned integers.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.\r\n * Use the container {@link BitStructure#addField|addField} helper\r\n * method.\r\n *\r\n * **NOTE** BitField instances are not instances of {@link Layout}\r\n * since {@link Layout#span|span} measures 8-bit units.\r\n *\r\n * @param {BitStructure} container - initializer for {@link\r\n * BitField#container|container}.\r\n *\r\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n */\n\n\nvar BitField = /*#__PURE__*/function () {\n  function BitField(container, bits, property) {\n    _classCallCheck(this, BitField);\n\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n\n    if (!Number.isInteger(bits) || 0 >= bits) {\n      throw new TypeError('bits must be positive integer');\n    }\n\n    var totalBits = 8 * container.span;\n    var usedBits = container.fields.reduce(function (sum, fd) {\n      return sum + fd.bits;\n    }, 0);\n\n    if (bits + usedBits > totalBits) {\n      throw new Error('bits too long for span remainder (' + (totalBits - usedBits) + ' of ' + totalBits + ' remain)');\n    }\n    /** The {@link BitStructure} instance to which this bit field\r\n     * belongs. */\n\n\n    this.container = container;\n    /** The span of this value in bits. */\n\n    this.bits = bits;\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\r\n     * that fit within the field.\r\n     *\r\n     * That is, it masks a value that has not yet been shifted into\r\n     * position within its containing packed integer. */\n\n    this.valueMask = (1 << bits) - 1;\n\n    if (32 === bits) {\n      // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n    /** The offset of the value within the containing packed unsigned\r\n     * integer.  The least significant bit of the packed value is at\r\n     * offset zero, regardless of bit ordering used. */\n\n\n    this.start = usedBits;\n\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n    /** A mask of {@link BitField#bits|bits} isolating the field value\r\n     * within the containing packed unsigned integer. */\n\n\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n    /** The property name used when this bitfield is represented in an\r\n     * Object.\r\n     *\r\n     * Intended to be functionally equivalent to {@link\r\n     * Layout#property}.\r\n     *\r\n     * If left undefined the corresponding span of bits will be\r\n     * treated as padding: it will not be mutated by {@link\r\n     * Layout#encode|encode} nor represented as a property in the\r\n     * decoded Object. */\n\n    this.property = property;\n  }\n  /** Store a value into the corresponding subsequence of the containing\r\n   * bit field. */\n\n\n  _createClass(BitField, [{\n    key: \"decode\",\n    value: function decode() {\n      var word = this.container._packedGetValue();\n\n      var wordValue = fixBitwiseResult(word & this.wordMask);\n      var value = wordValue >>> this.start;\n      return value;\n    }\n    /** Store a value into the corresponding subsequence of the containing\r\n     * bit field.\r\n     *\r\n     * **NOTE** This is not a specialization of {@link\r\n     * Layout#encode|Layout.encode} and there is no return value. */\n\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n        throw new TypeError(nameWithProperty('BitField.encode', this) + ' value must be integer not exceeding ' + this.valueMask);\n      }\n\n      var word = this.container._packedGetValue();\n\n      var wordValue = fixBitwiseResult(value << this.start);\n\n      this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n    }\n  }]);\n\n  return BitField;\n}();\n/**\r\n * Represent a single bit within a {@link BitStructure} as a\r\n * JavaScript boolean.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.\r\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\r\n * method.\r\n *\r\n * @param {BitStructure} container - initializer for {@link\r\n * BitField#container|container}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {BitField}\r\n */\n\n/* eslint-disable no-extend-native */\n\n\nvar Boolean = /*#__PURE__*/function (_BitField) {\n  _inherits(Boolean, _BitField);\n\n  var _super22 = _createSuper(Boolean);\n\n  function Boolean(container, property) {\n    _classCallCheck(this, Boolean);\n\n    return _super22.call(this, container, 1, property);\n  }\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\r\n   *\r\n   * @returns {boolean} */\n\n\n  _createClass(Boolean, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      return !!BitField.prototype.decode.call(this, b, offset);\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if ('boolean' === typeof value) {\n        // BitField requires integer values\n        value = +value;\n      }\n\n      return BitField.prototype.encode.call(this, value);\n    }\n  }]);\n\n  return Boolean;\n}(BitField);\n/* eslint-enable no-extend-native */\n\n/**\r\n * Contain a fixed-length block of arbitrary data, represented as a\r\n * Buffer.\r\n *\r\n * *Factory*: {@link module:Layout.blob|blob}\r\n *\r\n * @param {(Number|ExternalLayout)} length - initializes {@link\r\n * Blob#length|length}.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar Blob = /*#__PURE__*/function (_Layout19) {\n  _inherits(Blob, _Layout19);\n\n  var _super23 = _createSuper(Blob);\n\n  function Blob(length, property) {\n    var _this13;\n\n    _classCallCheck(this, Blob);\n\n    if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n      throw new TypeError('length must be positive integer ' + 'or an unsigned integer ExternalLayout');\n    }\n\n    var span = -1;\n\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n\n    _this13 = _super23.call(this, span, property);\n    /** The number of bytes in the blob.\r\n     *\r\n     * This may be a non-negative integer, or an instance of {@link\r\n     * ExternalLayout} that satisfies {@link\r\n     * ExternalLayout#isCount|isCount()}. */\n\n    _this13.length = length;\n    return _this13;\n  }\n  /** @override */\n\n\n  _createClass(Blob, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      var span = this.span;\n\n      if (0 > span) {\n        span = this.length.decode(b, offset);\n      }\n\n      return span;\n    }\n    /** @override */\n\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var span = this.span;\n\n      if (0 > span) {\n        span = this.length.decode(b, offset);\n      }\n\n      return b.slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\r\n     *\r\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\r\n     * ExternalLayout} then the length of `src` will be encoded as the\r\n     * count after `src` is encoded. */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      var span = this.length;\n\n      if (this.length instanceof ExternalLayout) {\n        span = src.length;\n      }\n\n      if (!(Buffer.isBuffer(src) && span === src.length)) {\n        throw new TypeError(nameWithProperty('Blob.encode', this) + ' requires (length ' + span + ') Buffer as src');\n      }\n\n      if (offset + span > b.length) {\n        throw new RangeError('encoding overruns Buffer');\n      }\n\n      b.write(src.toString('hex'), offset, span, 'hex');\n\n      if (this.length instanceof ExternalLayout) {\n        this.length.encode(span, b, offset);\n      }\n\n      return span;\n    }\n  }]);\n\n  return Blob;\n}(Layout);\n/**\r\n * Contain a `NUL`-terminated UTF8 string.\r\n *\r\n * *Factory*: {@link module:Layout.cstr|cstr}\r\n *\r\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\r\n * not be correctly decoded by this layout.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar CString = /*#__PURE__*/function (_Layout20) {\n  _inherits(CString, _Layout20);\n\n  var _super24 = _createSuper(CString);\n\n  function CString(property) {\n    _classCallCheck(this, CString);\n\n    return _super24.call(this, -1, property);\n  }\n  /** @override */\n\n\n  _createClass(CString, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (!Buffer.isBuffer(b)) {\n        throw new TypeError('b must be a Buffer');\n      }\n\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var idx = offset;\n\n      while (idx < b.length && 0 !== b[idx]) {\n        idx += 1;\n      }\n\n      return 1 + idx - offset;\n    }\n    /** @override */\n\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset, dest) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var span = this.getSpan(b, offset);\n      return b.slice(offset, offset + span - 1).toString('utf-8');\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      /* Must force this to a string, lest it be a number and the\r\n       * \"utf8-encoding\" below actually allocate a buffer of length\r\n       * src */\n\n\n      if ('string' !== typeof src) {\n        src = src.toString();\n      }\n\n      var srcb = new Buffer(src, 'utf8');\n      var span = srcb.length;\n\n      if (offset + span > b.length) {\n        throw new RangeError('encoding overruns Buffer');\n      }\n\n      srcb.copy(b, offset);\n      b[offset + span] = 0;\n      return span + 1;\n    }\n  }]);\n\n  return CString;\n}(Layout);\n/**\r\n * Contain a UTF8 string with implicit length.\r\n *\r\n * *Factory*: {@link module:Layout.utf8|utf8}\r\n *\r\n * **NOTE** Because the length is implicit in the size of the buffer\r\n * this layout should be used only in isolation, or in a situation\r\n * where the length can be expressed by operating on a slice of the\r\n * containing buffer.\r\n *\r\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\r\n * string content.  If not provided there is no bound on the allowed\r\n * content.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar UTF8 = /*#__PURE__*/function (_Layout21) {\n  _inherits(UTF8, _Layout21);\n\n  var _super25 = _createSuper(UTF8);\n\n  function UTF8(maxSpan, property) {\n    var _this14;\n\n    _classCallCheck(this, UTF8);\n\n    if ('string' === typeof maxSpan && undefined === property) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n\n    _this14 = _super25.call(this, -1, property);\n    /** The maximum span of the layout in bytes.\r\n     *\r\n     * Positive values are generally expected.  Zero is abnormal.\r\n     * Attempts to encode or decode a value that exceeds this length\r\n     * will throw a `RangeError`.\r\n     *\r\n     * A negative value indicates that there is no bound on the length\r\n     * of the content. */\n\n    _this14.maxSpan = maxSpan;\n    return _this14;\n  }\n  /** @override */\n\n\n  _createClass(UTF8, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (!Buffer.isBuffer(b)) {\n        throw new TypeError('b must be a Buffer');\n      }\n\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      return b.length - offset;\n    }\n    /** @override */\n\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset, dest) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      var span = this.getSpan(b, offset);\n\n      if (0 <= this.maxSpan && this.maxSpan < span) {\n        throw new RangeError('text length exceeds maxSpan');\n      }\n\n      return b.slice(offset, offset + span).toString('utf-8');\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      /* Must force this to a string, lest it be a number and the\r\n       * \"utf8-encoding\" below actually allocate a buffer of length\r\n       * src */\n\n\n      if ('string' !== typeof src) {\n        src = src.toString();\n      }\n\n      var srcb = new Buffer(src, 'utf8');\n      var span = srcb.length;\n\n      if (0 <= this.maxSpan && this.maxSpan < span) {\n        throw new RangeError('text length exceeds maxSpan');\n      }\n\n      if (offset + span > b.length) {\n        throw new RangeError('encoding overruns Buffer');\n      }\n\n      srcb.copy(b, offset);\n      return span;\n    }\n  }]);\n\n  return UTF8;\n}(Layout);\n/**\r\n * Contain a constant value.\r\n *\r\n * This layout may be used in cases where a JavaScript value can be\r\n * inferred without an expression in the binary encoding.  An example\r\n * would be a {@link VariantLayout|variant layout} where the content\r\n * is implied by the union {@link Union#discriminator|discriminator}.\r\n *\r\n * @param {Object|Number|String} value - initializer for {@link\r\n * Constant#value|value}.  If the value is an object (or array) and\r\n * the application intends the object to remain unchanged regardless\r\n * of what is done to values decoded by this layout, the value should\r\n * be frozen prior passing it to this constructor.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar Constant = /*#__PURE__*/function (_Layout22) {\n  _inherits(Constant, _Layout22);\n\n  var _super26 = _createSuper(Constant);\n\n  function Constant(value, property) {\n    var _this15;\n\n    _classCallCheck(this, Constant);\n\n    _this15 = _super26.call(this, 0, property);\n    /** The value produced by this constant when the layout is {@link\r\n     * Constant#decode|decoded}.\r\n     *\r\n     * Any JavaScript value including `null` and `undefined` is\r\n     * permitted.\r\n     *\r\n     * **WARNING** If `value` passed in the constructor was not\r\n     * frozen, it is possible for users of decoded values to change\r\n     * the content of the value. */\n\n    _this15.value = value;\n    return _this15;\n  }\n  /** @override */\n\n\n  _createClass(Constant, [{\n    key: \"decode\",\n    value: function decode(b, offset, dest) {\n      return this.value;\n    }\n    /** @override */\n\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      /* Constants take no space */\n      return 0;\n    }\n  }]);\n\n  return Constant;\n}(Layout);\n\nexports.ExternalLayout = ExternalLayout;\nexports.GreedyCount = GreedyCount;\nexports.OffsetLayout = OffsetLayout;\nexports.UInt = UInt;\nexports.UIntBE = UIntBE;\nexports.Int = Int;\nexports.IntBE = IntBE;\nexports.Float = Float;\nexports.FloatBE = FloatBE;\nexports.Double = Double;\nexports.DoubleBE = DoubleBE;\nexports.Sequence = Sequence;\nexports.Structure = Structure;\nexports.UnionDiscriminator = UnionDiscriminator;\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\nexports.Union = Union;\nexports.VariantLayout = VariantLayout;\nexports.BitStructure = BitStructure;\nexports.BitField = BitField;\nexports.Boolean = Boolean;\nexports.Blob = Blob;\nexports.CString = CString;\nexports.UTF8 = UTF8;\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */\n\nexports.greedy = function (elementSpan, property) {\n  return new GreedyCount(elementSpan, property);\n};\n/** Factory for {@link OffsetLayout}. */\n\n\nexports.offset = function (layout, offset, property) {\n  return new OffsetLayout(layout, offset, property);\n};\n/** Factory for {@link UInt|unsigned int layouts} spanning one\r\n * byte. */\n\n\nexports.u8 = function (property) {\n  return new UInt(1, property);\n};\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning two bytes. */\n\n\nexports.u16 = function (property) {\n  return new UInt(2, property);\n};\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning three bytes. */\n\n\nexports.u24 = function (property) {\n  return new UInt(3, property);\n};\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning four bytes. */\n\n\nexports.u32 = function (property) {\n  return new UInt(4, property);\n};\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning five bytes. */\n\n\nexports.u40 = function (property) {\n  return new UInt(5, property);\n};\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning six bytes. */\n\n\nexports.u48 = function (property) {\n  return new UInt(6, property);\n};\n/** Factory for {@link NearUInt64|little-endian unsigned int\r\n * layouts} interpreted as Numbers. */\n\n\nexports.nu64 = function (property) {\n  return new NearUInt64(property);\n};\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning two bytes. */\n\n\nexports.u16be = function (property) {\n  return new UIntBE(2, property);\n};\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning three bytes. */\n\n\nexports.u24be = function (property) {\n  return new UIntBE(3, property);\n};\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning four bytes. */\n\n\nexports.u32be = function (property) {\n  return new UIntBE(4, property);\n};\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning five bytes. */\n\n\nexports.u40be = function (property) {\n  return new UIntBE(5, property);\n};\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning six bytes. */\n\n\nexports.u48be = function (property) {\n  return new UIntBE(6, property);\n};\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\r\n * layouts} interpreted as Numbers. */\n\n\nexports.nu64be = function (property) {\n  return new NearUInt64BE(property);\n};\n/** Factory for {@link Int|signed int layouts} spanning one\r\n * byte. */\n\n\nexports.s8 = function (property) {\n  return new Int(1, property);\n};\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning two bytes. */\n\n\nexports.s16 = function (property) {\n  return new Int(2, property);\n};\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning three bytes. */\n\n\nexports.s24 = function (property) {\n  return new Int(3, property);\n};\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning four bytes. */\n\n\nexports.s32 = function (property) {\n  return new Int(4, property);\n};\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning five bytes. */\n\n\nexports.s40 = function (property) {\n  return new Int(5, property);\n};\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning six bytes. */\n\n\nexports.s48 = function (property) {\n  return new Int(6, property);\n};\n/** Factory for {@link NearInt64|little-endian signed int layouts}\r\n * interpreted as Numbers. */\n\n\nexports.ns64 = function (property) {\n  return new NearInt64(property);\n};\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning two bytes. */\n\n\nexports.s16be = function (property) {\n  return new IntBE(2, property);\n};\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning three bytes. */\n\n\nexports.s24be = function (property) {\n  return new IntBE(3, property);\n};\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning four bytes. */\n\n\nexports.s32be = function (property) {\n  return new IntBE(4, property);\n};\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning five bytes. */\n\n\nexports.s40be = function (property) {\n  return new IntBE(5, property);\n};\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning six bytes. */\n\n\nexports.s48be = function (property) {\n  return new IntBE(6, property);\n};\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\r\n * interpreted as Numbers. */\n\n\nexports.ns64be = function (property) {\n  return new NearInt64BE(property);\n};\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\n\n\nexports.f32 = function (property) {\n  return new Float(property);\n};\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\n\n\nexports.f32be = function (property) {\n  return new FloatBE(property);\n};\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\n\n\nexports.f64 = function (property) {\n  return new Double(property);\n};\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\n\n\nexports.f64be = function (property) {\n  return new DoubleBE(property);\n};\n/** Factory for {@link Structure} values. */\n\n\nexports.struct = function (fields, property, decodePrefixes) {\n  return new Structure(fields, property, decodePrefixes);\n};\n/** Factory for {@link BitStructure} values. */\n\n\nexports.bits = function (word, msb, property) {\n  return new BitStructure(word, msb, property);\n};\n/** Factory for {@link Sequence} values. */\n\n\nexports.seq = function (elementLayout, count, property) {\n  return new Sequence(elementLayout, count, property);\n};\n/** Factory for {@link Union} values. */\n\n\nexports.union = function (discr, defaultLayout, property) {\n  return new Union(discr, defaultLayout, property);\n};\n/** Factory for {@link UnionLayoutDiscriminator} values. */\n\n\nexports.unionLayoutDiscriminator = function (layout, property) {\n  return new UnionLayoutDiscriminator(layout, property);\n};\n/** Factory for {@link Blob} values. */\n\n\nexports.blob = function (length, property) {\n  return new Blob(length, property);\n};\n/** Factory for {@link CString} values. */\n\n\nexports.cstr = function (property) {\n  return new CString(property);\n};\n/** Factory for {@link UTF8} values. */\n\n\nexports.utf8 = function (maxSpan, property) {\n  return new UTF8(maxSpan, property);\n};\n/** Factory for {@link Constant} values. */\n\n\nexports.const = function (value, property) {\n  return new Constant(value, property);\n};","map":{"version":3,"sources":["D:/Lianok/dev/new-project/node_modules/buffer-layout/lib/Layout.js"],"names":["Layout","span","property","Number","isInteger","TypeError","b","offset","Error","src","RangeError","rv","Object","create","constructor","prototype","assign","values","undefined","exports","nameWithProperty","name","lo","bindConstructorLayout","Class","layout","hasOwnProperty","layout_","boundConstructor_","makeDestinationObject","defineProperty","value","encode","writable","decode","ExternalLayout","GreedyCount","elementSpan","rem","length","Math","floor","OffsetLayout","UInt","UIntBE","readUIntLE","writeUIntLE","readUIntBE","writeUIntBE","Int","readIntLE","writeIntLE","IntBE","readIntBE","writeIntBE","V2E32","pow","divmodInt64","hi32","lo32","roundedInt64","NearUInt64","readUInt32LE","split","writeUInt32LE","NearUInt64BE","readUInt32BE","writeUInt32BE","NearInt64","readInt32LE","writeInt32LE","NearInt64BE","readInt32BE","writeInt32BE","Float","readFloatLE","writeFloatLE","FloatBE","readFloatBE","writeFloatBE","Double","readDoubleLE","writeDoubleLE","DoubleBE","readDoubleBE","writeDoubleBE","Sequence","elementLayout","count","isCount","idx","getSpan","i","push","elo","reduce","v","Structure","fields","decodePrefixes","Array","isArray","acc","fd","e","fsp","dest","firstOffset","lastOffset","lastWrote","fv","shift","UnionDiscriminator","UnionLayoutDiscriminator","Union","discr","defaultLayout","upv","replicate","discriminator","usesPrefixDiscriminator","registry","boundGetSourceVariant","defaultGetSourceVariant","bind","getSourceVariant","configGetSourceVariant","gsv","vlo","getVariant","tag","dlo","clo","contentOffset","variant","VariantLayout","vb","Buffer","isBuffer","union","fromArray","fixBitwiseResult","BitStructure","word","msb","_packedSetValue","_packedGetValue","bits","bf","BitField","Boolean","container","totalBits","usedBits","sum","valueMask","start","wordMask","wordValue","call","Blob","slice","write","toString","CString","srcb","copy","UTF8","maxSpan","Constant","greedy","u8","u16","u24","u32","u40","u48","nu64","u16be","u24be","u32be","u40be","u48be","nu64be","s8","s16","s24","s32","s40","s48","ns64","s16be","s24be","s32be","s40be","s48be","ns64be","f32","f32be","f64","f64be","struct","seq","unionLayoutDiscriminator","blob","cstr","utf8","const"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;IACMA,M;AACJ,kBAAYC,IAAZ,EAAkBC,QAAlB,EAA4B;AAAA;;AAC1B,QAAI,CAACC,MAAM,CAACC,SAAP,CAAiBH,IAAjB,CAAL,EAA6B;AAC3B,YAAM,IAAII,SAAJ,CAAc,yBAAd,CAAN;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,SAAKJ,IAAL,GAAYA,IAAZ;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,SAAKC,QAAL,GAAgBA,QAAhB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACE,iCAAwB;AACtB,aAAO,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,gBAAOI,CAAP,EAAUC,MAAV,EAAkB;AAChB,YAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,gBAAOC,GAAP,EAAYH,CAAZ,EAAeC,MAAf,EAAuB;AACrB,YAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,iBAAQF,CAAR,EAAWC,MAAX,EAAmB;AACjB,UAAI,IAAI,KAAKN,IAAb,EAAmB;AACjB,cAAM,IAAIS,UAAJ,CAAe,oBAAf,CAAN;AACD;;AACD,aAAO,KAAKT,IAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,mBAAUC,QAAV,EAAoB;AAClB,UAAMS,EAAE,GAAGC,MAAM,CAACC,MAAP,CAAc,KAAKC,WAAL,CAAiBC,SAA/B,CAAX;AACAH,MAAAA,MAAM,CAACI,MAAP,CAAcL,EAAd,EAAkB,IAAlB;AACAA,MAAAA,EAAE,CAACT,QAAH,GAAcA,QAAd;AACA,aAAOS,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,mBAAUM,MAAV,EAAkB;AAChB,aAAOC,SAAP;AACD;;;;;;AAEHC,OAAO,CAACnB,MAAR,GAAiBA,MAAjB;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASoB,gBAAT,CAA0BC,IAA1B,EAAgCC,EAAhC,EAAoC;AAClC,MAAIA,EAAE,CAACpB,QAAP,EAAiB;AACf,WAAOmB,IAAI,GAAG,GAAP,GAAaC,EAAE,CAACpB,QAAhB,GAA2B,GAAlC;AACD;;AACD,SAAOmB,IAAP;AAC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","sourcesContent":["/* The MIT License (MIT)\r\n *\r\n * Copyright 2015-2018 Peter A. Bigot\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * Support for translating between Buffer instances and JavaScript\r\n * native types.\r\n *\r\n * {@link module:Layout~Layout|Layout} is the basis of a class\r\n * hierarchy that associates property names with sequences of encoded\r\n * bytes.\r\n *\r\n * Layouts are supported for these scalar (numeric) types:\r\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\r\n *   format} with {@link module:Layout.u8|8-bit}, {@link\r\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\r\n *   {@link module:Layout.u32|32-bit}, {@link\r\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\r\n *   representation ranges;\r\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\r\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\r\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\r\n *   {@link module:Layout.u40be|40-bit}, and {@link\r\n *   module:Layout.u48be|48-bit} representation ranges;\r\n * * {@link module:Layout~Int|Signed integers in little-endian\r\n *   format} with {@link module:Layout.s8|8-bit}, {@link\r\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\r\n *   {@link module:Layout.s32|32-bit}, {@link\r\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\r\n *   representation ranges;\r\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\r\n *   with {@link module:Layout.s16be|16-bit}, {@link\r\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\r\n *   {@link module:Layout.s40be|40-bit}, and {@link\r\n *   module:Layout.s48be|48-bit} representation ranges;\r\n * * 64-bit integral values that decode to an exact (if magnitude is\r\n *   less than 2^53) or nearby integral Number in {@link\r\n *   module:Layout.nu64|unsigned little-endian}, {@link\r\n *   module:Layout.nu64be|unsigned big-endian}, {@link\r\n *   module:Layout.ns64|signed little-endian}, and {@link\r\n *   module:Layout.ns64be|unsigned big-endian} encodings;\r\n * * 32-bit floating point values with {@link\r\n *   module:Layout.f32|little-endian} and {@link\r\n *   module:Layout.f32be|big-endian} representations;\r\n * * 64-bit floating point values with {@link\r\n *   module:Layout.f64|little-endian} and {@link\r\n *   module:Layout.f64be|big-endian} representations;\r\n * * {@link module:Layout.const|Constants} that take no space in the\r\n *   encoded expression.\r\n *\r\n * and for these aggregate types:\r\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\r\n *   module:Layout~Layout|Layout}, with JavaScript representation as\r\n *   an Array and constant or data-dependent {@link\r\n *   module:Layout~Sequence#count|length};\r\n * * {@link module:Layout.struct|Structure}s that aggregate a\r\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\r\n *   instances, with JavaScript representation as an Object;\r\n * * {@link module:Layout.union|Union}s that support multiple {@link\r\n *   module:Layout~VariantLayout|variant layouts} over a fixed\r\n *   (padded) or variable (not padded) span of bytes, using an\r\n *   unsigned integer at the start of the data or a separate {@link\r\n *   module:Layout.unionLayoutDiscriminator|layout element} to\r\n *   determine which layout to use when interpreting the buffer\r\n *   contents;\r\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\r\n *   of individual {@link\r\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\r\n *   16, 24, or 32-bit unsigned integer starting at the least- or\r\n *   most-significant bit;\r\n * * {@link module:Layout.cstr|C strings} of varying length;\r\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\r\n *   module:Layout~Blob#length|length} raw data.\r\n *\r\n * All {@link module:Layout~Layout|Layout} instances are immutable\r\n * after construction, to prevent internal state from becoming\r\n * inconsistent.\r\n *\r\n * @local Layout\r\n * @local ExternalLayout\r\n * @local GreedyCount\r\n * @local OffsetLayout\r\n * @local UInt\r\n * @local UIntBE\r\n * @local Int\r\n * @local IntBE\r\n * @local NearUInt64\r\n * @local NearUInt64BE\r\n * @local NearInt64\r\n * @local NearInt64BE\r\n * @local Float\r\n * @local FloatBE\r\n * @local Double\r\n * @local DoubleBE\r\n * @local Sequence\r\n * @local Structure\r\n * @local UnionDiscriminator\r\n * @local UnionLayoutDiscriminator\r\n * @local Union\r\n * @local VariantLayout\r\n * @local BitStructure\r\n * @local BitField\r\n * @local Boolean\r\n * @local Blob\r\n * @local CString\r\n * @local Constant\r\n * @local bindConstructorLayout\r\n * @module Layout\r\n * @license MIT\r\n * @author Peter A. Bigot\r\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\r\n */\r\n\r\n'use strict';\r\n\r\n/**\r\n * Base class for layout objects.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support the {@link\r\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\r\n *\r\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\r\n * parameter must be an integer; a negative value signifies that the\r\n * span is {@link Layout#getSpan|value-specific}.\r\n *\r\n * @param {string} [property] - Initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @abstract\r\n */\r\nclass Layout {\r\n  constructor(span, property) {\r\n    if (!Number.isInteger(span)) {\r\n      throw new TypeError('span must be an integer');\r\n    }\r\n\r\n    /** The span of the layout in bytes.\r\n     *\r\n     * Positive values are generally expected.\r\n     *\r\n     * Zero will only appear in {@link Constant}s and in {@link\r\n     * Sequence}s where the {@link Sequence#count|count} is zero.\r\n     *\r\n     * A negative value indicates that the span is value-specific, and\r\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\r\n    this.span = span;\r\n\r\n    /** The property name used when this layout is represented in an\r\n     * Object.\r\n     *\r\n     * Used only for layouts that {@link Layout#decode|decode} to Object\r\n     * instances.  If left undefined the span of the unnamed layout will\r\n     * be treated as padding: it will not be mutated by {@link\r\n     * Layout#encode|encode} nor represented as a property in the\r\n     * decoded Object. */\r\n    this.property = property;\r\n  }\r\n\r\n  /** Function to create an Object into which decoded properties will\r\n   * be written.\r\n   *\r\n   * Used only for layouts that {@link Layout#decode|decode} to Object\r\n   * instances, which means:\r\n   * * {@link Structure}\r\n   * * {@link Union}\r\n   * * {@link VariantLayout}\r\n   * * {@link BitStructure}\r\n   *\r\n   * If left undefined the JavaScript representation of these layouts\r\n   * will be Object instances.\r\n   *\r\n   * See {@link bindConstructorLayout}.\r\n   */\r\n  makeDestinationObject() {\r\n    return {};\r\n  }\r\n\r\n  /**\r\n   * Decode from a Buffer into an JavaScript value.\r\n   *\r\n   * @param {Buffer} b - the buffer from which encoded data is read.\r\n   *\r\n   * @param {Number} [offset] - the offset at which the encoded data\r\n   * starts.  If absent a zero offset is inferred.\r\n   *\r\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\r\n   *\r\n   * @abstract\r\n   */\r\n  decode(b, offset) {\r\n    throw new Error('Layout is abstract');\r\n  }\r\n\r\n  /**\r\n   * Encode a JavaScript value into a Buffer.\r\n   *\r\n   * @param {(Number|Array|Object)} src - the value to be encoded into\r\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\r\n   * Layout}.\r\n   *\r\n   * @param {Buffer} b - the buffer into which encoded data will be\r\n   * written.\r\n   *\r\n   * @param {Number} [offset] - the offset at which the encoded data\r\n   * starts.  If absent a zero offset is inferred.\r\n   *\r\n   * @returns {Number} - the number of bytes encoded, including the\r\n   * space skipped for internal padding, but excluding data such as\r\n   * {@link Sequence#count|lengths} when stored {@link\r\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\r\n   * producing the offset where data for the next layout would be\r\n   * written.\r\n   *\r\n   * @abstract\r\n   */\r\n  encode(src, b, offset) {\r\n    throw new Error('Layout is abstract');\r\n  }\r\n\r\n  /**\r\n   * Calculate the span of a specific instance of a layout.\r\n   *\r\n   * @param {Buffer} b - the buffer that contains an encoded instance.\r\n   *\r\n   * @param {Number} [offset] - the offset at which the encoded instance\r\n   * starts.  If absent a zero offset is inferred.\r\n   *\r\n   * @return {Number} - the number of bytes covered by the layout\r\n   * instance.  If this method is not overridden in a subclass the\r\n   * definition-time constant {@link Layout#span|span} will be\r\n   * returned.\r\n   *\r\n   * @throws {RangeError} - if the length of the value cannot be\r\n   * determined.\r\n   */\r\n  getSpan(b, offset) {\r\n    if (0 > this.span) {\r\n      throw new RangeError('indeterminate span');\r\n    }\r\n    return this.span;\r\n  }\r\n\r\n  /**\r\n   * Replicate the layout using a new property.\r\n   *\r\n   * This function must be used to get a structurally-equivalent layout\r\n   * with a different name since all {@link Layout} instances are\r\n   * immutable.\r\n   *\r\n   * **NOTE** This is a shallow copy.  All fields except {@link\r\n   * Layout#property|property} are strictly equal to the origin layout.\r\n   *\r\n   * @param {String} property - the value for {@link\r\n   * Layout#property|property} in the replica.\r\n   *\r\n   * @returns {Layout} - the copy with {@link Layout#property|property}\r\n   * set to `property`.\r\n   */\r\n  replicate(property) {\r\n    const rv = Object.create(this.constructor.prototype);\r\n    Object.assign(rv, this);\r\n    rv.property = property;\r\n    return rv;\r\n  }\r\n\r\n  /**\r\n   * Create an object from layout properties and an array of values.\r\n   *\r\n   * **NOTE** This function returns `undefined` if invoked on a layout\r\n   * that does not return its value as an Object.  Objects are\r\n   * returned for things that are a {@link Structure}, which includes\r\n   * {@link VariantLayout|variant layouts} if they are structures, and\r\n   * excludes {@link Union}s.  If you want this feature for a union\r\n   * you must use {@link Union.getVariant|getVariant} to select the\r\n   * desired layout.\r\n   *\r\n   * @param {Array} values - an array of values that correspond to the\r\n   * default order for properties.  As with {@link Layout#decode|decode}\r\n   * layout elements that have no property name are skipped when\r\n   * iterating over the array values.  Only the top-level properties are\r\n   * assigned; arguments are not assigned to properties of contained\r\n   * layouts.  Any unused values are ignored.\r\n   *\r\n   * @return {(Object|undefined)}\r\n   */\r\n  fromArray(values) {\r\n    return undefined;\r\n  }\r\n}\r\nexports.Layout = Layout;\r\n\r\n/* Provide text that carries a name (such as for a function that will\r\n * be throwing an error) annotated with the property of a given layout\r\n * (such as one for which the value was unacceptable).\r\n *\r\n * @ignore */\r\nfunction nameWithProperty(name, lo) {\r\n  if (lo.property) {\r\n    return name + '[' + lo.property + ']';\r\n  }\r\n  return name;\r\n}\r\nexports.nameWithProperty = nameWithProperty;\r\n\r\n/**\r\n * Augment a class so that instances can be encoded/decoded using a\r\n * given layout.\r\n *\r\n * Calling this function couples `Class` with `layout` in several ways:\r\n *\r\n * * `Class.layout_` becomes a static member property equal to `layout`;\r\n * * `layout.boundConstructor_` becomes a static member property equal\r\n *    to `Class`;\r\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\r\n *   property of `layout` is set to a function that returns a `new\r\n *   Class()`;\r\n * * `Class.decode(b, offset)` becomes a static member function that\r\n *   delegates to {@link Layout#decode|layout.decode}.  The\r\n *   synthesized function may be captured and extended.\r\n * * `Class.prototype.encode(b, offset)` provides an instance member\r\n *   function that delegates to {@link Layout#encode|layout.encode}\r\n *   with `src` set to `this`.  The synthesized function may be\r\n *   captured and extended, but when the extension is invoked `this`\r\n *   must be explicitly bound to the instance.\r\n *\r\n * @param {class} Class - a JavaScript class with a nullary\r\n * constructor.\r\n *\r\n * @param {Layout} layout - the {@link Layout} instance used to encode\r\n * instances of `Class`.\r\n */\r\nfunction bindConstructorLayout(Class, layout) {\r\n  if ('function' !== typeof Class) {\r\n    throw new TypeError('Class must be constructor');\r\n  }\r\n  if (Class.hasOwnProperty('layout_')) {\r\n    throw new Error('Class is already bound to a layout');\r\n  }\r\n  if (!(layout && (layout instanceof Layout))) {\r\n    throw new TypeError('layout must be a Layout');\r\n  }\r\n  if (layout.hasOwnProperty('boundConstructor_')) {\r\n    throw new Error('layout is already bound to a constructor');\r\n  }\r\n  Class.layout_ = layout;\r\n  layout.boundConstructor_ = Class;\r\n  layout.makeDestinationObject = (() => new Class());\r\n  Object.defineProperty(Class.prototype, 'encode', {\r\n    value: function(b, offset) {\r\n      return layout.encode(this, b, offset);\r\n    },\r\n    writable: true,\r\n  });\r\n  Object.defineProperty(Class, 'decode', {\r\n    value: function(b, offset) {\r\n      return layout.decode(b, offset);\r\n    },\r\n    writable: true,\r\n  });\r\n}\r\nexports.bindConstructorLayout = bindConstructorLayout;\r\n\r\n/**\r\n * An object that behaves like a layout but does not consume space\r\n * within its containing layout.\r\n *\r\n * This is primarily used to obtain metadata about a member, such as a\r\n * {@link OffsetLayout} that can provide data about a {@link\r\n * Layout#getSpan|value-specific span}.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support {@link\r\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @abstract\r\n * @augments {Layout}\r\n */\r\nclass ExternalLayout extends Layout {\r\n  /**\r\n   * Return `true` iff the external layout decodes to an unsigned\r\n   * integer layout.\r\n   *\r\n   * In that case it can be used as the source of {@link\r\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\r\n   * or as {@link UnionLayoutDiscriminator#layout|external union\r\n   * discriminators}.\r\n   *\r\n   * @abstract\r\n   */\r\n  isCount() {\r\n    throw new Error('ExternalLayout is abstract');\r\n  }\r\n}\r\n\r\n/**\r\n * An {@link ExternalLayout} that determines its {@link\r\n * Layout#decode|value} based on offset into and length of the buffer\r\n * on which it is invoked.\r\n *\r\n * *Factory*: {@link module:Layout.greedy|greedy}\r\n *\r\n * @param {Number} [elementSpan] - initializer for {@link\r\n * GreedyCount#elementSpan|elementSpan}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {ExternalLayout}\r\n */\r\nclass GreedyCount extends ExternalLayout {\r\n  constructor(elementSpan, property) {\r\n    if (undefined === elementSpan) {\r\n      elementSpan = 1;\r\n    }\r\n    if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {\r\n      throw new TypeError('elementSpan must be a (positive) integer');\r\n    }\r\n    super(-1, property);\r\n\r\n    /** The layout for individual elements of the sequence.  The value\r\n     * must be a positive integer.  If not provided, the value will be\r\n     * 1. */\r\n    this.elementSpan = elementSpan;\r\n  }\r\n\r\n  /** @override */\r\n  isCount() {\r\n    return true;\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const rem = b.length - offset;\r\n    return Math.floor(rem / this.elementSpan);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\r\n * at a fixed offset from the start of another Layout.  The offset may\r\n * be before, within, or after the base layout.\r\n *\r\n * *Factory*: {@link module:Layout.offset|offset}\r\n *\r\n * @param {Layout} layout - initializer for {@link\r\n * OffsetLayout#layout|layout}, modulo `property`.\r\n *\r\n * @param {Number} [offset] - Initializes {@link\r\n * OffsetLayout#offset|offset}.  Defaults to zero.\r\n *\r\n * @param {string} [property] - Optional new property name for a\r\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\r\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\r\n * unchanged.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass OffsetLayout extends ExternalLayout {\r\n  constructor(layout, offset, property) {\r\n    if (!(layout instanceof Layout)) {\r\n      throw new TypeError('layout must be a Layout');\r\n    }\r\n\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    } else if (!Number.isInteger(offset)) {\r\n      throw new TypeError('offset must be integer or undefined');\r\n    }\r\n\r\n    super(layout.span, property || layout.property);\r\n\r\n    /** The subordinated layout. */\r\n    this.layout = layout;\r\n\r\n    /** The location of {@link OffsetLayout#layout} relative to the\r\n     * start of another layout.\r\n     *\r\n     * The value may be positive or negative, but an error will thrown\r\n     * if at the point of use it goes outside the span of the Buffer\r\n     * being accessed.  */\r\n    this.offset = offset;\r\n  }\r\n\r\n  /** @override */\r\n  isCount() {\r\n    return ((this.layout instanceof UInt)\r\n            || (this.layout instanceof UIntBE));\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    return this.layout.decode(b, offset + this.offset);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    return this.layout.encode(src, b, offset + this.offset);\r\n  }\r\n}\r\n\r\n/**\r\n * Represent an unsigned integer in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.u8|u8}, {@link\r\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\r\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\r\n *  module:Layout.u48|u48}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass UInt extends Layout {\r\n  constructor(span, property) {\r\n    super(span, property);\r\n    if (6 < this.span) {\r\n      throw new RangeError('span must not exceed 6 bytes');\r\n    }\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    return b.readUIntLE(offset, this.span);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    b.writeUIntLE(src, offset, this.span);\r\n    return this.span;\r\n  }\r\n}\r\n\r\n/**\r\n * Represent an unsigned integer in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\r\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\r\n * {@link module:Layout.u32be|u32be}, {@link\r\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass UIntBE extends Layout {\r\n  constructor(span, property) {\r\n    super( span, property);\r\n    if (6 < this.span) {\r\n      throw new RangeError('span must not exceed 6 bytes');\r\n    }\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    return b.readUIntBE(offset, this.span);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    b.writeUIntBE(src, offset, this.span);\r\n    return this.span;\r\n  }\r\n}\r\n\r\n/**\r\n * Represent a signed integer in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.s8|s8}, {@link\r\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\r\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\r\n *  module:Layout.s48|s48}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass Int extends Layout {\r\n  constructor(span, property) {\r\n    super(span, property);\r\n    if (6 < this.span) {\r\n      throw new RangeError('span must not exceed 6 bytes');\r\n    }\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    return b.readIntLE(offset, this.span);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    b.writeIntLE(src, offset, this.span);\r\n    return this.span;\r\n  }\r\n}\r\n\r\n/**\r\n * Represent a signed integer in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\r\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\r\n * {@link module:Layout.s32be|s32be}, {@link\r\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass IntBE extends Layout {\r\n  constructor(span, property) {\r\n    super(span, property);\r\n    if (6 < this.span) {\r\n      throw new RangeError('span must not exceed 6 bytes');\r\n    }\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    return b.readIntBE(offset, this.span);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    b.writeIntBE(src, offset, this.span);\r\n    return this.span;\r\n  }\r\n}\r\n\r\nconst V2E32 = Math.pow(2, 32);\r\n\r\n/* True modulus high and low 32-bit words, where low word is always\r\n * non-negative. */\r\nfunction divmodInt64(src) {\r\n  const hi32 = Math.floor(src / V2E32);\r\n  const lo32 = src - (hi32 * V2E32);\r\n  return {hi32, lo32};\r\n}\r\n/* Reconstruct Number from quotient and non-negative remainder */\r\nfunction roundedInt64(hi32, lo32) {\r\n  return hi32 * V2E32 + lo32;\r\n}\r\n\r\n/**\r\n * Represent an unsigned 64-bit integer in little-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.nu64|nu64}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass NearUInt64 extends Layout {\r\n  constructor(property) {\r\n    super(8, property);\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const lo32 = b.readUInt32LE(offset);\r\n    const hi32 = b.readUInt32LE(offset + 4);\r\n    return roundedInt64(hi32, lo32);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const split = divmodInt64(src);\r\n    b.writeUInt32LE(split.lo32, offset);\r\n    b.writeUInt32LE(split.hi32, offset + 4);\r\n    return 8;\r\n  }\r\n}\r\n\r\n/**\r\n * Represent an unsigned 64-bit integer in big-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.nu64be|nu64be}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass NearUInt64BE extends Layout {\r\n  constructor(property) {\r\n    super(8, property);\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const hi32 = b.readUInt32BE(offset);\r\n    const lo32 = b.readUInt32BE(offset + 4);\r\n    return roundedInt64(hi32, lo32);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const split = divmodInt64(src);\r\n    b.writeUInt32BE(split.hi32, offset);\r\n    b.writeUInt32BE(split.lo32, offset + 4);\r\n    return 8;\r\n  }\r\n}\r\n\r\n/**\r\n * Represent a signed 64-bit integer in little-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.ns64|ns64}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass NearInt64 extends Layout {\r\n  constructor(property) {\r\n    super(8, property);\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const lo32 = b.readUInt32LE(offset);\r\n    const hi32 = b.readInt32LE(offset + 4);\r\n    return roundedInt64(hi32, lo32);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const split = divmodInt64(src);\r\n    b.writeUInt32LE(split.lo32, offset);\r\n    b.writeInt32LE(split.hi32, offset + 4);\r\n    return 8;\r\n  }\r\n}\r\n\r\n/**\r\n * Represent a signed 64-bit integer in big-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.ns64be|ns64be}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass NearInt64BE extends Layout {\r\n  constructor(property) {\r\n    super(8, property);\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const hi32 = b.readInt32BE(offset);\r\n    const lo32 = b.readUInt32BE(offset + 4);\r\n    return roundedInt64(hi32, lo32);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const split = divmodInt64(src);\r\n    b.writeInt32BE(split.hi32, offset);\r\n    b.writeUInt32BE(split.lo32, offset + 4);\r\n    return 8;\r\n  }\r\n}\r\n\r\n/**\r\n * Represent a 32-bit floating point number in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f32|f32}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass Float extends Layout {\r\n  constructor(property) {\r\n    super(4, property);\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    return b.readFloatLE(offset);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    b.writeFloatLE(src, offset);\r\n    return 4;\r\n  }\r\n}\r\n\r\n/**\r\n * Represent a 32-bit floating point number in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f32be|f32be}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass FloatBE extends Layout {\r\n  constructor(property) {\r\n    super(4, property);\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    return b.readFloatBE(offset);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    b.writeFloatBE(src, offset);\r\n    return 4;\r\n  }\r\n}\r\n\r\n/**\r\n * Represent a 64-bit floating point number in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f64|f64}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass Double extends Layout {\r\n  constructor(property) {\r\n    super(8, property);\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    return b.readDoubleLE(offset);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    b.writeDoubleLE(src, offset);\r\n    return 8;\r\n  }\r\n}\r\n\r\n/**\r\n * Represent a 64-bit floating point number in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f64be|f64be}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass DoubleBE extends Layout {\r\n  constructor(property) {\r\n    super(8, property);\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    return b.readDoubleBE(offset);\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    b.writeDoubleBE(src, offset);\r\n    return 8;\r\n  }\r\n}\r\n\r\n/**\r\n * Represent a contiguous sequence of a specific layout as an Array.\r\n *\r\n * *Factory*: {@link module:Layout.seq|seq}\r\n *\r\n * @param {Layout} elementLayout - initializer for {@link\r\n * Sequence#elementLayout|elementLayout}.\r\n *\r\n * @param {(Number|ExternalLayout)} count - initializer for {@link\r\n * Sequence#count|count}.  The parameter must be either a positive\r\n * integer or an instance of {@link ExternalLayout}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass Sequence extends Layout {\r\n  constructor(elementLayout, count, property) {\r\n    if (!(elementLayout instanceof Layout)) {\r\n      throw new TypeError('elementLayout must be a Layout');\r\n    }\r\n    if (!(((count instanceof ExternalLayout) && count.isCount())\r\n          || (Number.isInteger(count) && (0 <= count)))) {\r\n      throw new TypeError('count must be non-negative integer '\r\n                          + 'or an unsigned integer ExternalLayout');\r\n    }\r\n    let span = -1;\r\n    if ((!(count instanceof ExternalLayout))\r\n        && (0 < elementLayout.span)) {\r\n      span = count * elementLayout.span;\r\n    }\r\n\r\n    super(span, property);\r\n\r\n    /** The layout for individual elements of the sequence. */\r\n    this.elementLayout = elementLayout;\r\n\r\n    /** The number of elements in the sequence.\r\n     *\r\n     * This will be either a non-negative integer or an instance of\r\n     * {@link ExternalLayout} for which {@link\r\n     * ExternalLayout#isCount|isCount()} is `true`. */\r\n    this.count = count;\r\n  }\r\n\r\n  /** @override */\r\n  getSpan(b, offset) {\r\n    if (0 <= this.span) {\r\n      return this.span;\r\n    }\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    let span = 0;\r\n    let count = this.count;\r\n    if (count instanceof ExternalLayout) {\r\n      count = count.decode(b, offset);\r\n    }\r\n    if (0 < this.elementLayout.span) {\r\n      span = count * this.elementLayout.span;\r\n    } else {\r\n      let idx = 0;\r\n      while (idx < count) {\r\n        span += this.elementLayout.getSpan(b, offset + span);\r\n        ++idx;\r\n      }\r\n    }\r\n    return span;\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const rv = [];\r\n    let i = 0;\r\n    let count = this.count;\r\n    if (count instanceof ExternalLayout) {\r\n      count = count.decode(b, offset);\r\n    }\r\n    while (i < count) {\r\n      rv.push(this.elementLayout.decode(b, offset));\r\n      offset += this.elementLayout.getSpan(b, offset);\r\n      i += 1;\r\n    }\r\n    return rv;\r\n  }\r\n\r\n  /** Implement {@link Layout#encode|encode} for {@link Sequence}.\r\n   *\r\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\r\n   * the unused space in the buffer is left unchanged.  If `src` is\r\n   * longer than {@link Sequence#count|count} the unneeded elements are\r\n   * ignored.\r\n   *\r\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\r\n   * ExternalLayout} then the length of `src` will be encoded as the\r\n   * count after `src` is encoded. */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const elo = this.elementLayout;\r\n    const span = src.reduce((span, v) => {\r\n      return span + elo.encode(v, b, offset + span);\r\n    }, 0);\r\n    if (this.count instanceof ExternalLayout) {\r\n      this.count.encode(src.length, b, offset);\r\n    }\r\n    return span;\r\n  }\r\n}\r\n\r\n/**\r\n * Represent a contiguous sequence of arbitrary layout elements as an\r\n * Object.\r\n *\r\n * *Factory*: {@link module:Layout.struct|struct}\r\n *\r\n * **NOTE** The {@link Layout#span|span} of the structure is variable\r\n * if any layout in {@link Structure#fields|fields} has a variable\r\n * span.  When {@link Layout#encode|encoding} we must have a value for\r\n * all variable-length fields, or we wouldn't be able to figure out\r\n * how much space to use for storage.  We can only identify the value\r\n * for a field when it has a {@link Layout#property|property}.  As\r\n * such, although a structure may contain both unnamed fields and\r\n * variable-length fields, it cannot contain an unnamed\r\n * variable-length field.\r\n *\r\n * @param {Layout[]} fields - initializer for {@link\r\n * Structure#fields|fields}.  An error is raised if this contains a\r\n * variable-length field for which a {@link Layout#property|property}\r\n * is not defined.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @param {Boolean} [decodePrefixes] - initializer for {@link\r\n * Structure#decodePrefixes|property}.\r\n *\r\n * @throws {Error} - if `fields` contains an unnamed variable-length\r\n * layout.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass Structure extends Layout {\r\n  constructor(fields, property, decodePrefixes) {\r\n    if (!(Array.isArray(fields)\r\n          && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {\r\n      throw new TypeError('fields must be array of Layout instances');\r\n    }\r\n    if (('boolean' === typeof property)\r\n        && (undefined === decodePrefixes)) {\r\n      decodePrefixes = property;\r\n      property = undefined;\r\n    }\r\n\r\n    /* Verify absence of unnamed variable-length fields. */\r\n    for (const fd of fields) {\r\n      if ((0 > fd.span)\r\n          && (undefined === fd.property)) {\r\n        throw new Error('fields cannot contain unnamed variable-length layout');\r\n      }\r\n    }\r\n\r\n    let span = -1;\r\n    try {\r\n      span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\r\n    } catch (e) {\r\n    }\r\n    super(span, property);\r\n\r\n    /** The sequence of {@link Layout} values that comprise the\r\n     * structure.\r\n     *\r\n     * The individual elements need not be the same type, and may be\r\n     * either scalar or aggregate layouts.  If a member layout leaves\r\n     * its {@link Layout#property|property} undefined the\r\n     * corresponding region of the buffer associated with the element\r\n     * will not be mutated.\r\n     *\r\n     * @type {Layout[]} */\r\n    this.fields = fields;\r\n\r\n    /** Control behavior of {@link Layout#decode|decode()} given short\r\n     * buffers.\r\n     *\r\n     * In some situations a structure many be extended with additional\r\n     * fields over time, with older installations providing only a\r\n     * prefix of the full structure.  If this property is `true`\r\n     * decoding will accept those buffers and leave subsequent fields\r\n     * undefined, as long as the buffer ends at a field boundary.\r\n     * Defaults to `false`. */\r\n    this.decodePrefixes = !!decodePrefixes;\r\n  }\r\n\r\n  /** @override */\r\n  getSpan(b, offset) {\r\n    if (0 <= this.span) {\r\n      return this.span;\r\n    }\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    let span = 0;\r\n    try {\r\n      span = this.fields.reduce((span, fd) => {\r\n        const fsp = fd.getSpan(b, offset);\r\n        offset += fsp;\r\n        return span + fsp;\r\n      }, 0);\r\n    } catch (e) {\r\n      throw new RangeError('indeterminate span');\r\n    }\r\n    return span;\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const dest = this.makeDestinationObject();\r\n    for (const fd of this.fields) {\r\n      if (undefined !== fd.property) {\r\n        dest[fd.property] = fd.decode(b, offset);\r\n      }\r\n      offset += fd.getSpan(b, offset);\r\n      if (this.decodePrefixes\r\n          && (b.length === offset)) {\r\n        break;\r\n      }\r\n    }\r\n    return dest;\r\n  }\r\n\r\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\r\n   *\r\n   * If `src` is missing a property for a member with a defined {@link\r\n   * Layout#property|property} the corresponding region of the buffer is\r\n   * left unmodified. */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const firstOffset = offset;\r\n    let lastOffset = 0;\r\n    let lastWrote = 0;\r\n    for (const fd of this.fields) {\r\n      let span = fd.span;\r\n      lastWrote = (0 < span) ? span : 0;\r\n      if (undefined !== fd.property) {\r\n        const fv = src[fd.property];\r\n        if (undefined !== fv) {\r\n          lastWrote = fd.encode(fv, b, offset);\r\n          if (0 > span) {\r\n            /* Read the as-encoded span, which is not necessarily the\r\n             * same as what we wrote. */\r\n            span = fd.getSpan(b, offset);\r\n          }\r\n        }\r\n      }\r\n      lastOffset = offset;\r\n      offset += span;\r\n    }\r\n    /* Use (lastOffset + lastWrote) instead of offset because the last\r\n     * item may have had a dynamic length and we don't want to include\r\n     * the padding between it and the end of the space reserved for\r\n     * it. */\r\n    return (lastOffset + lastWrote) - firstOffset;\r\n  }\r\n\r\n  /** @override */\r\n  fromArray(values) {\r\n    const dest = this.makeDestinationObject();\r\n    for (const fd of this.fields) {\r\n      if ((undefined !== fd.property)\r\n          && (0 < values.length)) {\r\n        dest[fd.property] = values.shift();\r\n      }\r\n    }\r\n    return dest;\r\n  }\r\n\r\n  /**\r\n   * Get access to the layout of a given property.\r\n   *\r\n   * @param {String} property - the structure member of interest.\r\n   *\r\n   * @return {Layout} - the layout associated with `property`, or\r\n   * undefined if there is no such property.\r\n   */\r\n  layoutFor(property) {\r\n    if ('string' !== typeof property) {\r\n      throw new TypeError('property must be string');\r\n    }\r\n    for (const fd of this.fields) {\r\n      if (fd.property === property) {\r\n        return fd;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the offset of a structure member.\r\n   *\r\n   * @param {String} property - the structure member of interest.\r\n   *\r\n   * @return {Number} - the offset in bytes to the start of `property`\r\n   * within the structure, or undefined if `property` is not a field\r\n   * within the structure.  If the property is a member but follows a\r\n   * variable-length structure member a negative number will be\r\n   * returned.\r\n   */\r\n  offsetOf(property) {\r\n    if ('string' !== typeof property) {\r\n      throw new TypeError('property must be string');\r\n    }\r\n    let offset = 0;\r\n    for (const fd of this.fields) {\r\n      if (fd.property === property) {\r\n        return offset;\r\n      }\r\n      if (0 > fd.span) {\r\n        offset = -1;\r\n      } else if (0 <= offset) {\r\n        offset += fd.span;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * An object that can provide a {@link\r\n * Union#discriminator|discriminator} API for {@link Union}.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support the {@link\r\n * UnionDiscriminator#encode|encode} or {@link\r\n * UnionDiscriminator#decode|decode} functions.\r\n *\r\n * @param {string} [property] - Default for {@link\r\n * UnionDiscriminator#property|property}.\r\n *\r\n * @abstract\r\n */\r\nclass UnionDiscriminator {\r\n  constructor(property) {\r\n    /** The {@link Layout#property|property} to be used when the\r\n     * discriminator is referenced in isolation (generally when {@link\r\n     * Union#decode|Union decode} cannot delegate to a specific\r\n     * variant). */\r\n    this.property = property;\r\n  }\r\n\r\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\r\n   *\r\n   * The implementation of this method need not reference the buffer if\r\n   * variant information is available through other means. */\r\n  decode() {\r\n    throw new Error('UnionDiscriminator is abstract');\r\n  }\r\n\r\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\r\n   *\r\n   * The implementation of this method need not store the value if\r\n   * variant information is maintained through other means. */\r\n  encode() {\r\n    throw new Error('UnionDiscriminator is abstract');\r\n  }\r\n}\r\n\r\n/**\r\n * An object that can provide a {@link\r\n * UnionDiscriminator|discriminator API} for {@link Union} using an\r\n * unsigned integral {@link Layout} instance located either inside or\r\n * outside the union.\r\n *\r\n * @param {ExternalLayout} layout - initializes {@link\r\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\r\n * ExternalLayout#isCount|isCount()}.\r\n *\r\n * @param {string} [property] - Default for {@link\r\n * UnionDiscriminator#property|property}, superseding the property\r\n * from `layout`, but defaulting to `variant` if neither `property`\r\n * nor layout provide a property name.\r\n *\r\n * @augments {UnionDiscriminator}\r\n */\r\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\r\n  constructor(layout, property) {\r\n    if (!((layout instanceof ExternalLayout)\r\n          && layout.isCount())) {\r\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\r\n    }\r\n\r\n    super(property || layout.property || 'variant');\r\n\r\n    /** The {@link ExternalLayout} used to access the discriminator\r\n     * value. */\r\n    this.layout = layout;\r\n  }\r\n\r\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\r\n  decode(b, offset) {\r\n    return this.layout.decode(b, offset);\r\n  }\r\n\r\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\r\n  encode(src, b, offset) {\r\n    return this.layout.encode(src, b, offset);\r\n  }\r\n}\r\n\r\n/**\r\n * Represent any number of span-compatible layouts.\r\n *\r\n * *Factory*: {@link module:Layout.union|union}\r\n *\r\n * If the union has a {@link Union#defaultLayout|default layout} that\r\n * layout must have a non-negative {@link Layout#span|span}.  The span\r\n * of a fixed-span union includes its {@link\r\n * Union#discriminator|discriminator} if the variant is a {@link\r\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\r\n * of its {@link Union#defaultLayout|default layout}.\r\n *\r\n * If the union does not have a default layout then the encoded span\r\n * of the union depends on the encoded span of its variant (which may\r\n * be fixed or variable).\r\n *\r\n * {@link VariantLayout#layout|Variant layout}s are added through\r\n * {@link Union#addVariant|addVariant}.  If the union has a default\r\n * layout, the span of the {@link VariantLayout#layout|layout\r\n * contained by the variant} must not exceed the span of the {@link\r\n * Union#defaultLayout|default layout} (minus the span of a {@link\r\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\r\n * span of the variant will equal the span of the union itself.\r\n *\r\n * The variant for a buffer can only be identified from the {@link\r\n * Union#discriminator|discriminator} {@link\r\n * UnionDiscriminator#property|property} (in the case of the {@link\r\n * Union#defaultLayout|default layout}), or by using {@link\r\n * Union#getVariant|getVariant} and examining the resulting {@link\r\n * VariantLayout} instance.\r\n *\r\n * A variant compatible with a JavaScript object can be identified\r\n * using {@link Union#getSourceVariant|getSourceVariant}.\r\n *\r\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\r\n * identify the layout used to interpret the union contents.  The\r\n * parameter must be an instance of {@link UnionDiscriminator}, an\r\n * {@link ExternalLayout} that satisfies {@link\r\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\r\n * UIntBE}).  When a non-external layout element is passed the layout\r\n * appears at the start of the union.  In all cases the (synthesized)\r\n * {@link UnionDiscriminator} instance is recorded as {@link\r\n * Union#discriminator|discriminator}.\r\n *\r\n * @param {(Layout|null)} defaultLayout - initializer for {@link\r\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\r\n * If `null` there is no default layout: the union has data-dependent\r\n * length and attempts to decode or encode unrecognized variants will\r\n * throw an exception.  A {@link Layout} instance must have a\r\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\r\n * Layout#property|property} the {@link\r\n * Union#defaultLayout|defaultLayout} will be a {@link\r\n * Layout#replicate|replica} with property `content`.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass Union extends Layout {\r\n  constructor(discr, defaultLayout, property) {\r\n    const upv = ((discr instanceof UInt)\r\n               || (discr instanceof UIntBE));\r\n    if (upv) {\r\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\r\n    } else if ((discr instanceof ExternalLayout)\r\n               && discr.isCount()) {\r\n      discr = new UnionLayoutDiscriminator(discr);\r\n    } else if (!(discr instanceof UnionDiscriminator)) {\r\n      throw new TypeError('discr must be a UnionDiscriminator '\r\n                          + 'or an unsigned integer layout');\r\n    }\r\n    if (undefined === defaultLayout) {\r\n      defaultLayout = null;\r\n    }\r\n    if (!((null === defaultLayout)\r\n          || (defaultLayout instanceof Layout))) {\r\n      throw new TypeError('defaultLayout must be null or a Layout');\r\n    }\r\n    if (null !== defaultLayout) {\r\n      if (0 > defaultLayout.span) {\r\n        throw new Error('defaultLayout must have constant span');\r\n      }\r\n      if (undefined === defaultLayout.property) {\r\n        defaultLayout = defaultLayout.replicate('content');\r\n      }\r\n    }\r\n\r\n    /* The union span can be estimated only if there's a default\r\n     * layout.  The union spans its default layout, plus any prefix\r\n     * variant layout.  By construction both layouts, if present, have\r\n     * non-negative span. */\r\n    let span = -1;\r\n    if (defaultLayout) {\r\n      span = defaultLayout.span;\r\n      if ((0 <= span) && upv) {\r\n        span += discr.layout.span;\r\n      }\r\n    }\r\n    super(span, property);\r\n\r\n    /** The interface for the discriminator value in isolation.\r\n     *\r\n     * This a {@link UnionDiscriminator} either passed to the\r\n     * constructor or synthesized from the `discr` constructor\r\n     * argument.  {@link\r\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\r\n     * `true` iff the `discr` parameter was a non-offset {@link\r\n     * Layout} instance. */\r\n    this.discriminator = discr;\r\n\r\n    /** `true` if the {@link Union#discriminator|discriminator} is the\r\n     * first field in the union.\r\n     *\r\n     * If `false` the discriminator is obtained from somewhere\r\n     * else. */\r\n    this.usesPrefixDiscriminator = upv;\r\n\r\n    /** The layout for non-discriminator content when the value of the\r\n     * discriminator is not recognized.\r\n     *\r\n     * This is the value passed to the constructor.  It is\r\n     * structurally equivalent to the second component of {@link\r\n     * Union#layout|layout} but may have a different property\r\n     * name. */\r\n    this.defaultLayout = defaultLayout;\r\n\r\n    /** A registry of allowed variants.\r\n     *\r\n     * The keys are unsigned integers which should be compatible with\r\n     * {@link Union.discriminator|discriminator}.  The property value\r\n     * is the corresponding {@link VariantLayout} instances assigned\r\n     * to this union by {@link Union#addVariant|addVariant}.\r\n     *\r\n     * **NOTE** The registry remains mutable so that variants can be\r\n     * {@link Union#addVariant|added} at any time.  Users should not\r\n     * manipulate the content of this property. */\r\n    this.registry = {};\r\n\r\n    /* Private variable used when invoking getSourceVariant */\r\n    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\r\n\r\n    /** Function to infer the variant selected by a source object.\r\n     *\r\n     * Defaults to {@link\r\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\r\n     * be overridden using {@link\r\n     * Union#configGetSourceVariant|configGetSourceVariant}.\r\n     *\r\n     * @param {Object} src - as with {@link\r\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\r\n     *\r\n     * @returns {(undefined|VariantLayout)} The default variant\r\n     * (`undefined`) or first registered variant that uses a property\r\n     * available in `src`. */\r\n    this.getSourceVariant = function(src) {\r\n      return boundGetSourceVariant(src);\r\n    };\r\n\r\n    /** Function to override the implementation of {@link\r\n     * Union#getSourceVariant|getSourceVariant}.\r\n     *\r\n     * Use this if the desired variant cannot be identified using the\r\n     * algorithm of {@link\r\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\r\n     *\r\n     * **NOTE** The provided function will be invoked bound to this\r\n     * Union instance, providing local access to {@link\r\n     * Union#registry|registry}.\r\n     *\r\n     * @param {Function} gsv - a function that follows the API of\r\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\r\n    this.configGetSourceVariant = function(gsv) {\r\n      boundGetSourceVariant = gsv.bind(this);\r\n    };\r\n  }\r\n\r\n  /** @override */\r\n  getSpan(b, offset) {\r\n    if (0 <= this.span) {\r\n      return this.span;\r\n    }\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    /* Default layouts always have non-negative span, so we don't have\r\n     * one and we have to recognize the variant which will in turn\r\n     * determine the span. */\r\n    const vlo = this.getVariant(b, offset);\r\n    if (!vlo) {\r\n      throw new Error('unable to determine span for unrecognized variant');\r\n    }\r\n    return vlo.getSpan(b, offset);\r\n  }\r\n\r\n  /**\r\n   * Method to infer a registered Union variant compatible with `src`.\r\n   *\r\n   * The first satisified rule in the following sequence defines the\r\n   * return value:\r\n   * * If `src` has properties matching the Union discriminator and\r\n   *   the default layout, `undefined` is returned regardless of the\r\n   *   value of the discriminator property (this ensures the default\r\n   *   layout will be used);\r\n   * * If `src` has a property matching the Union discriminator, the\r\n   *   value of the discriminator identifies a registered variant, and\r\n   *   either (a) the variant has no layout, or (b) `src` has the\r\n   *   variant's property, then the variant is returned (because the\r\n   *   source satisfies the constraints of the variant it identifies);\r\n   * * If `src` does not have a property matching the Union\r\n   *   discriminator, but does have a property matching a registered\r\n   *   variant, then the variant is returned (because the source\r\n   *   matches a variant without an explicit conflict);\r\n   * * An error is thrown (because we either can't identify a variant,\r\n   *   or we were explicitly told the variant but can't satisfy it).\r\n   *\r\n   * @param {Object} src - an object presumed to be compatible with\r\n   * the content of the Union.\r\n   *\r\n   * @return {(undefined|VariantLayout)} - as described above.\r\n   *\r\n   * @throws {Error} - if `src` cannot be associated with a default or\r\n   * registered variant.\r\n   */\r\n  defaultGetSourceVariant(src) {\r\n    if (src.hasOwnProperty(this.discriminator.property)) {\r\n      if (this.defaultLayout\r\n          && src.hasOwnProperty(this.defaultLayout.property)) {\r\n        return undefined;\r\n      }\r\n      const vlo = this.registry[src[this.discriminator.property]];\r\n      if (vlo\r\n          && ((!vlo.layout)\r\n              || src.hasOwnProperty(vlo.property))) {\r\n        return vlo;\r\n      }\r\n    } else {\r\n      for (const tag in this.registry) {\r\n        const vlo = this.registry[tag];\r\n        if (src.hasOwnProperty(vlo.property)) {\r\n          return vlo;\r\n        }\r\n      }\r\n    }\r\n    throw new Error('unable to infer src variant');\r\n  }\r\n\r\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\r\n   *\r\n   * If the variant is {@link Union#addVariant|registered} the return\r\n   * value is an instance of that variant, with no explicit\r\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\r\n   * layout} is used to decode the content. */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    let dest;\r\n    const dlo = this.discriminator;\r\n    const discr = dlo.decode(b, offset);\r\n    let clo = this.registry[discr];\r\n    if (undefined === clo) {\r\n      let contentOffset = 0;\r\n      clo = this.defaultLayout;\r\n      if (this.usesPrefixDiscriminator) {\r\n        contentOffset = dlo.layout.span;\r\n      }\r\n      dest = this.makeDestinationObject();\r\n      dest[dlo.property] = discr;\r\n      dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\r\n    } else {\r\n      dest = clo.decode(b, offset);\r\n    }\r\n    return dest;\r\n  }\r\n\r\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\r\n   *\r\n   * This API assumes the `src` object is consistent with the union's\r\n   * {@link Union#defaultLayout|default layout}.  To encode variants\r\n   * use the appropriate variant-specific {@link VariantLayout#encode}\r\n   * method. */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const vlo = this.getSourceVariant(src);\r\n    if (undefined === vlo) {\r\n      const dlo = this.discriminator;\r\n      const clo = this.defaultLayout;\r\n      let contentOffset = 0;\r\n      if (this.usesPrefixDiscriminator) {\r\n        contentOffset = dlo.layout.span;\r\n      }\r\n      dlo.encode(src[dlo.property], b, offset);\r\n      return contentOffset + clo.encode(src[clo.property], b,\r\n                                        offset + contentOffset);\r\n    }\r\n    return vlo.encode(src, b, offset);\r\n  }\r\n\r\n  /** Register a new variant structure within a union.  The newly\r\n   * created variant is returned.\r\n   *\r\n   * @param {Number} variant - initializer for {@link\r\n   * VariantLayout#variant|variant}.\r\n   *\r\n   * @param {Layout} layout - initializer for {@link\r\n   * VariantLayout#layout|layout}.\r\n   *\r\n   * @param {String} property - initializer for {@link\r\n   * Layout#property|property}.\r\n   *\r\n   * @return {VariantLayout} */\r\n  addVariant(variant, layout, property) {\r\n    const rv = new VariantLayout(this, variant, layout, property);\r\n    this.registry[variant] = rv;\r\n    return rv;\r\n  }\r\n\r\n  /**\r\n   * Get the layout associated with a registered variant.\r\n   *\r\n   * If `vb` does not produce a registered variant the function returns\r\n   * `undefined`.\r\n   *\r\n   * @param {(Number|Buffer)} vb - either the variant number, or a\r\n   * buffer from which the discriminator is to be read.\r\n   *\r\n   * @param {Number} offset - offset into `vb` for the start of the\r\n   * union.  Used only when `vb` is an instance of {Buffer}.\r\n   *\r\n   * @return {({VariantLayout}|undefined)}\r\n   */\r\n  getVariant(vb, offset) {\r\n    let variant = vb;\r\n    if (Buffer.isBuffer(vb)) {\r\n      if (undefined === offset) {\r\n        offset = 0;\r\n      }\r\n      variant = this.discriminator.decode(vb, offset);\r\n    }\r\n    return this.registry[variant];\r\n  }\r\n}\r\n\r\n/**\r\n * Represent a specific variant within a containing union.\r\n *\r\n * **NOTE** The {@link Layout#span|span} of the variant may include\r\n * the span of the {@link Union#discriminator|discriminator} used to\r\n * identify it, but values read and written using the variant strictly\r\n * conform to the content of {@link VariantLayout#layout|layout}.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.  Use\r\n * the union {@link Union#addVariant|addVariant} helper method.\r\n *\r\n * @param {Union} union - initializer for {@link\r\n * VariantLayout#union|union}.\r\n *\r\n * @param {Number} variant - initializer for {@link\r\n * VariantLayout#variant|variant}.\r\n *\r\n * @param {Layout} [layout] - initializer for {@link\r\n * VariantLayout#layout|layout}.  If absent the variant carries no\r\n * data.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.  Unlike many other layouts, variant\r\n * layouts normally include a property name so they can be identified\r\n * within their containing {@link Union}.  The property identifier may\r\n * be absent only if `layout` is is absent.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass VariantLayout extends Layout {\r\n  constructor(union, variant, layout, property) {\r\n    if (!(union instanceof Union)) {\r\n      throw new TypeError('union must be a Union');\r\n    }\r\n    if ((!Number.isInteger(variant)) || (0 > variant)) {\r\n      throw new TypeError('variant must be a (non-negative) integer');\r\n    }\r\n    if (('string' === typeof layout)\r\n        && (undefined === property)) {\r\n      property = layout;\r\n      layout = null;\r\n    }\r\n    if (layout) {\r\n      if (!(layout instanceof Layout)) {\r\n        throw new TypeError('layout must be a Layout');\r\n      }\r\n      if ((null !== union.defaultLayout)\r\n          && (0 <= layout.span)\r\n          && (layout.span > union.defaultLayout.span)) {\r\n        throw new Error('variant span exceeds span of containing union');\r\n      }\r\n      if ('string' !== typeof property) {\r\n        throw new TypeError('variant must have a String property');\r\n      }\r\n    }\r\n    let span = union.span;\r\n    if (0 > union.span) {\r\n      span = layout ? layout.span : 0;\r\n      if ((0 <= span) && union.usesPrefixDiscriminator) {\r\n        span += union.discriminator.layout.span;\r\n      }\r\n    }\r\n    super(span, property);\r\n\r\n    /** The {@link Union} to which this variant belongs. */\r\n    this.union = union;\r\n\r\n    /** The unsigned integral value identifying this variant within\r\n     * the {@link Union#discriminator|discriminator} of the containing\r\n     * union. */\r\n    this.variant = variant;\r\n\r\n    /** The {@link Layout} to be used when reading/writing the\r\n     * non-discriminator part of the {@link\r\n     * VariantLayout#union|union}.  If `null` the variant carries no\r\n     * data. */\r\n    this.layout = layout || null;\r\n  }\r\n\r\n  /** @override */\r\n  getSpan(b, offset) {\r\n    if (0 <= this.span) {\r\n      /* Will be equal to the containing union span if that is not\r\n       * variable. */\r\n      return this.span;\r\n    }\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    let contentOffset = 0;\r\n    if (this.union.usesPrefixDiscriminator) {\r\n      contentOffset = this.union.discriminator.layout.span;\r\n    }\r\n    /* Span is defined solely by the variant (and prefix discriminator) */\r\n    return contentOffset + this.layout.getSpan(b, offset + contentOffset);\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    const dest = this.makeDestinationObject();\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    if (this !== this.union.getVariant(b, offset)) {\r\n      throw new Error('variant mismatch');\r\n    }\r\n    let contentOffset = 0;\r\n    if (this.union.usesPrefixDiscriminator) {\r\n      contentOffset = this.union.discriminator.layout.span;\r\n    }\r\n    if (this.layout) {\r\n      dest[this.property] = this.layout.decode(b, offset + contentOffset);\r\n    } else if (this.property) {\r\n      dest[this.property] = true;\r\n    } else if (this.union.usesPrefixDiscriminator) {\r\n      dest[this.union.discriminator.property] = this.variant;\r\n    }\r\n    return dest;\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    let contentOffset = 0;\r\n    if (this.union.usesPrefixDiscriminator) {\r\n      contentOffset = this.union.discriminator.layout.span;\r\n    }\r\n    if (this.layout\r\n        && (!src.hasOwnProperty(this.property))) {\r\n      throw new TypeError('variant lacks property ' + this.property);\r\n    }\r\n    this.union.discriminator.encode(this.variant, b, offset);\r\n    let span = contentOffset;\r\n    if (this.layout) {\r\n      this.layout.encode(src[this.property], b, offset + contentOffset);\r\n      span += this.layout.getSpan(b, offset + contentOffset);\r\n      if ((0 <= this.union.span)\r\n          && (span > this.union.span)) {\r\n        throw new Error('encoded variant overruns containing union');\r\n      }\r\n    }\r\n    return span;\r\n  }\r\n\r\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\r\n   * VariantLayout#layout|layout}. */\r\n  fromArray(values) {\r\n    if (this.layout) {\r\n      return this.layout.fromArray(values);\r\n    }\r\n  }\r\n}\r\n\r\n/** JavaScript chose to define bitwise operations as operating on\r\n * signed 32-bit values in 2's complement form, meaning any integer\r\n * with bit 31 set is going to look negative.  For right shifts that's\r\n * not a problem, because `>>>` is a logical shift, but for every\r\n * other bitwise operator we have to compensate for possible negative\r\n * results. */\r\nfunction fixBitwiseResult(v) {\r\n  if (0 > v) {\r\n    v += 0x100000000;\r\n  }\r\n  return v;\r\n}\r\n\r\n/**\r\n * Contain a sequence of bit fields as an unsigned integer.\r\n *\r\n * *Factory*: {@link module:Layout.bits|bits}\r\n *\r\n * This is a container element; within it there are {@link BitField}\r\n * instances that provide the extracted properties.  The container\r\n * simply defines the aggregate representation and its bit ordering.\r\n * The representation is an object containing properties with numeric\r\n * or {@link Boolean} values.\r\n *\r\n * {@link BitField}s are added with the {@link\r\n * BitStructure#addField|addField} and {@link\r\n * BitStructure#addBoolean|addBoolean} methods.\r\n\r\n * @param {Layout} word - initializer for {@link\r\n * BitStructure#word|word}.  The parameter must be an instance of\r\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\r\n *\r\n * @param {bool} [msb] - `true` if the bit numbering starts at the\r\n * most significant bit of the containing word; `false` (default) if\r\n * it starts at the least significant bit of the containing word.  If\r\n * the parameter at this position is a string and `property` is\r\n * `undefined` the value of this argument will instead be used as the\r\n * value of `property`.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass BitStructure extends Layout {\r\n  constructor(word, msb, property) {\r\n    if (!((word instanceof UInt)\r\n          || (word instanceof UIntBE))) {\r\n      throw new TypeError('word must be a UInt or UIntBE layout');\r\n    }\r\n    if (('string' === typeof msb)\r\n        && (undefined === property)) {\r\n      property = msb;\r\n      msb = undefined;\r\n    }\r\n    if (4 < word.span) {\r\n      throw new RangeError('word cannot exceed 32 bits');\r\n    }\r\n    super(word.span, property);\r\n\r\n    /** The layout used for the packed value.  {@link BitField}\r\n     * instances are packed sequentially depending on {@link\r\n     * BitStructure#msb|msb}. */\r\n    this.word = word;\r\n\r\n    /** Whether the bit sequences are packed starting at the most\r\n     * significant bit growing down (`true`), or the least significant\r\n     * bit growing up (`false`).\r\n     *\r\n     * **NOTE** Regardless of this value, the least significant bit of\r\n     * any {@link BitField} value is the least significant bit of the\r\n     * corresponding section of the packed value. */\r\n    this.msb = !!msb;\r\n\r\n    /** The sequence of {@link BitField} layouts that comprise the\r\n     * packed structure.\r\n     *\r\n     * **NOTE** The array remains mutable to allow fields to be {@link\r\n     * BitStructure#addField|added} after construction.  Users should\r\n     * not manipulate the content of this property.*/\r\n    this.fields = [];\r\n\r\n    /* Storage for the value.  Capture a variable instead of using an\r\n     * instance property because we don't want anything to change the\r\n     * value without going through the mutator. */\r\n    let value = 0;\r\n    this._packedSetValue = function(v) {\r\n      value = fixBitwiseResult(v);\r\n      return this;\r\n    };\r\n    this._packedGetValue = function() {\r\n      return value;\r\n    };\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    const dest = this.makeDestinationObject();\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const value = this.word.decode(b, offset);\r\n    this._packedSetValue(value);\r\n    for (const fd of this.fields) {\r\n      if (undefined !== fd.property) {\r\n        dest[fd.property] = fd.decode(value);\r\n      }\r\n    }\r\n    return dest;\r\n  }\r\n\r\n  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\r\n   *\r\n   * If `src` is missing a property for a member with a defined {@link\r\n   * Layout#property|property} the corresponding region of the packed\r\n   * value is left unmodified.  Unused bits are also left unmodified. */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    const value = this.word.decode(b, offset);\r\n    this._packedSetValue(value);\r\n    for (const fd of this.fields) {\r\n      if (undefined !== fd.property) {\r\n        const fv = src[fd.property];\r\n        if (undefined !== fv) {\r\n          fd.encode(fv);\r\n        }\r\n      }\r\n    }\r\n    return this.word.encode(this._packedGetValue(), b, offset);\r\n  }\r\n\r\n  /** Register a new bitfield with a containing bit structure.  The\r\n   * resulting bitfield is returned.\r\n   *\r\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\r\n   *\r\n   * @param {string} property - initializer for {@link\r\n   * Layout#property|property}.\r\n   *\r\n   * @return {BitField} */\r\n  addField(bits, property) {\r\n    const bf = new BitField(this, bits, property);\r\n    this.fields.push(bf);\r\n    return bf;\r\n  }\r\n\r\n  /** As with {@link BitStructure#addField|addField} for single-bit\r\n   * fields with `boolean` value representation.\r\n   *\r\n   * @param {string} property - initializer for {@link\r\n   * Layout#property|property}.\r\n   *\r\n   * @return {Boolean} */\r\n  addBoolean(property) {\r\n    // This is my Boolean, not the Javascript one.\r\n    // eslint-disable-next-line no-new-wrappers\r\n    const bf = new Boolean(this, property);\r\n    this.fields.push(bf);\r\n    return bf;\r\n  }\r\n\r\n  /**\r\n   * Get access to the bit field for a given property.\r\n   *\r\n   * @param {String} property - the bit field of interest.\r\n   *\r\n   * @return {BitField} - the field associated with `property`, or\r\n   * undefined if there is no such property.\r\n   */\r\n  fieldFor(property) {\r\n    if ('string' !== typeof property) {\r\n      throw new TypeError('property must be string');\r\n    }\r\n    for (const fd of this.fields) {\r\n      if (fd.property === property) {\r\n        return fd;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Represent a sequence of bits within a {@link BitStructure}.\r\n *\r\n * All bit field values are represented as unsigned integers.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.\r\n * Use the container {@link BitStructure#addField|addField} helper\r\n * method.\r\n *\r\n * **NOTE** BitField instances are not instances of {@link Layout}\r\n * since {@link Layout#span|span} measures 8-bit units.\r\n *\r\n * @param {BitStructure} container - initializer for {@link\r\n * BitField#container|container}.\r\n *\r\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n */\r\nclass BitField {\r\n  constructor(container, bits, property) {\r\n    if (!(container instanceof BitStructure)) {\r\n      throw new TypeError('container must be a BitStructure');\r\n    }\r\n    if ((!Number.isInteger(bits)) || (0 >= bits)) {\r\n      throw new TypeError('bits must be positive integer');\r\n    }\r\n    const totalBits = 8 * container.span;\r\n    const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\r\n    if ((bits + usedBits) > totalBits) {\r\n      throw new Error('bits too long for span remainder ('\r\n                      + (totalBits - usedBits) + ' of '\r\n                      + totalBits + ' remain)');\r\n    }\r\n\r\n    /** The {@link BitStructure} instance to which this bit field\r\n     * belongs. */\r\n    this.container = container;\r\n\r\n    /** The span of this value in bits. */\r\n    this.bits = bits;\r\n\r\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\r\n     * that fit within the field.\r\n     *\r\n     * That is, it masks a value that has not yet been shifted into\r\n     * position within its containing packed integer. */\r\n    this.valueMask = (1 << bits) - 1;\r\n    if (32 === bits) { // shifted value out of range\r\n      this.valueMask = 0xFFFFFFFF;\r\n    }\r\n\r\n    /** The offset of the value within the containing packed unsigned\r\n     * integer.  The least significant bit of the packed value is at\r\n     * offset zero, regardless of bit ordering used. */\r\n    this.start = usedBits;\r\n    if (this.container.msb) {\r\n      this.start = totalBits - usedBits - bits;\r\n    }\r\n\r\n    /** A mask of {@link BitField#bits|bits} isolating the field value\r\n     * within the containing packed unsigned integer. */\r\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\r\n\r\n    /** The property name used when this bitfield is represented in an\r\n     * Object.\r\n     *\r\n     * Intended to be functionally equivalent to {@link\r\n     * Layout#property}.\r\n     *\r\n     * If left undefined the corresponding span of bits will be\r\n     * treated as padding: it will not be mutated by {@link\r\n     * Layout#encode|encode} nor represented as a property in the\r\n     * decoded Object. */\r\n    this.property = property;\r\n  }\r\n\r\n  /** Store a value into the corresponding subsequence of the containing\r\n   * bit field. */\r\n  decode() {\r\n    const word = this.container._packedGetValue();\r\n    const wordValue = fixBitwiseResult(word & this.wordMask);\r\n    const value = wordValue >>> this.start;\r\n    return value;\r\n  }\r\n\r\n  /** Store a value into the corresponding subsequence of the containing\r\n   * bit field.\r\n   *\r\n   * **NOTE** This is not a specialization of {@link\r\n   * Layout#encode|Layout.encode} and there is no return value. */\r\n  encode(value) {\r\n    if ((!Number.isInteger(value))\r\n        || (value !== fixBitwiseResult(value & this.valueMask))) {\r\n      throw new TypeError(nameWithProperty('BitField.encode', this)\r\n                          + ' value must be integer not exceeding ' + this.valueMask);\r\n    }\r\n    const word = this.container._packedGetValue();\r\n    const wordValue = fixBitwiseResult(value << this.start);\r\n    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)\r\n                                   | wordValue);\r\n  };\r\n}\r\n\r\n/**\r\n * Represent a single bit within a {@link BitStructure} as a\r\n * JavaScript boolean.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.\r\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\r\n * method.\r\n *\r\n * @param {BitStructure} container - initializer for {@link\r\n * BitField#container|container}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {BitField}\r\n */\r\n/* eslint-disable no-extend-native */\r\nclass Boolean extends BitField {\r\n  constructor(container, property) {\r\n    super(container, 1, property);\r\n  }\r\n\r\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\r\n   *\r\n   * @returns {boolean} */\r\n  decode(b, offset) {\r\n    return !!BitField.prototype.decode.call(this, b, offset);\r\n  }\r\n\r\n  /** @override */\r\n  encode(value) {\r\n    if ('boolean' === typeof value) {\r\n      // BitField requires integer values\r\n      value = +value;\r\n    }\r\n    return BitField.prototype.encode.call(this, value);\r\n  }\r\n}\r\n/* eslint-enable no-extend-native */\r\n\r\n/**\r\n * Contain a fixed-length block of arbitrary data, represented as a\r\n * Buffer.\r\n *\r\n * *Factory*: {@link module:Layout.blob|blob}\r\n *\r\n * @param {(Number|ExternalLayout)} length - initializes {@link\r\n * Blob#length|length}.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass Blob extends Layout {\r\n  constructor(length, property) {\r\n    if (!(((length instanceof ExternalLayout) && length.isCount())\r\n          || (Number.isInteger(length) && (0 <= length)))) {\r\n      throw new TypeError('length must be positive integer '\r\n                          + 'or an unsigned integer ExternalLayout');\r\n    }\r\n\r\n    let span = -1;\r\n    if (!(length instanceof ExternalLayout)) {\r\n      span = length;\r\n    }\r\n    super(span, property);\r\n\r\n    /** The number of bytes in the blob.\r\n     *\r\n     * This may be a non-negative integer, or an instance of {@link\r\n     * ExternalLayout} that satisfies {@link\r\n     * ExternalLayout#isCount|isCount()}. */\r\n    this.length = length;\r\n  }\r\n\r\n  /** @override */\r\n  getSpan(b, offset) {\r\n    let span = this.span;\r\n    if (0 > span) {\r\n      span = this.length.decode(b, offset);\r\n    }\r\n    return span;\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    let span = this.span;\r\n    if (0 > span) {\r\n      span = this.length.decode(b, offset);\r\n    }\r\n    return b.slice(offset, offset + span);\r\n  }\r\n\r\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\r\n   *\r\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\r\n   * ExternalLayout} then the length of `src` will be encoded as the\r\n   * count after `src` is encoded. */\r\n  encode(src, b, offset) {\r\n    let span = this.length;\r\n    if (this.length instanceof ExternalLayout) {\r\n      span = src.length;\r\n    }\r\n    if (!(Buffer.isBuffer(src)\r\n          && (span === src.length))) {\r\n      throw new TypeError(nameWithProperty('Blob.encode', this)\r\n                          + ' requires (length ' + span + ') Buffer as src');\r\n    }\r\n    if ((offset + span) > b.length) {\r\n      throw new RangeError('encoding overruns Buffer');\r\n    }\r\n    b.write(src.toString('hex'), offset, span, 'hex');\r\n    if (this.length instanceof ExternalLayout) {\r\n      this.length.encode(span, b, offset);\r\n    }\r\n    return span;\r\n  }\r\n}\r\n\r\n/**\r\n * Contain a `NUL`-terminated UTF8 string.\r\n *\r\n * *Factory*: {@link module:Layout.cstr|cstr}\r\n *\r\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\r\n * not be correctly decoded by this layout.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass CString extends Layout {\r\n  constructor(property) {\r\n    super(-1, property);\r\n  }\r\n\r\n  /** @override */\r\n  getSpan(b, offset) {\r\n    if (!Buffer.isBuffer(b)) {\r\n      throw new TypeError('b must be a Buffer');\r\n    }\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    let idx = offset;\r\n    while ((idx < b.length) && (0 !== b[idx])) {\r\n      idx += 1;\r\n    }\r\n    return 1 + idx - offset;\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset, dest) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    let span = this.getSpan(b, offset);\r\n    return b.slice(offset, offset + span - 1).toString('utf-8');\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    /* Must force this to a string, lest it be a number and the\r\n     * \"utf8-encoding\" below actually allocate a buffer of length\r\n     * src */\r\n    if ('string' !== typeof src) {\r\n      src = src.toString();\r\n    }\r\n    const srcb = new Buffer(src, 'utf8');\r\n    const span = srcb.length;\r\n    if ((offset + span) > b.length) {\r\n      throw new RangeError('encoding overruns Buffer');\r\n    }\r\n    srcb.copy(b, offset);\r\n    b[offset + span] = 0;\r\n    return span + 1;\r\n  }\r\n}\r\n\r\n/**\r\n * Contain a UTF8 string with implicit length.\r\n *\r\n * *Factory*: {@link module:Layout.utf8|utf8}\r\n *\r\n * **NOTE** Because the length is implicit in the size of the buffer\r\n * this layout should be used only in isolation, or in a situation\r\n * where the length can be expressed by operating on a slice of the\r\n * containing buffer.\r\n *\r\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\r\n * string content.  If not provided there is no bound on the allowed\r\n * content.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass UTF8 extends Layout {\r\n  constructor(maxSpan, property) {\r\n    if (('string' === typeof maxSpan)\r\n        && (undefined === property)) {\r\n      property = maxSpan;\r\n      maxSpan = undefined;\r\n    }\r\n    if (undefined === maxSpan) {\r\n      maxSpan = -1;\r\n    } else if (!Number.isInteger(maxSpan)) {\r\n      throw new TypeError('maxSpan must be an integer');\r\n    }\r\n\r\n    super(-1, property);\r\n\r\n    /** The maximum span of the layout in bytes.\r\n     *\r\n     * Positive values are generally expected.  Zero is abnormal.\r\n     * Attempts to encode or decode a value that exceeds this length\r\n     * will throw a `RangeError`.\r\n     *\r\n     * A negative value indicates that there is no bound on the length\r\n     * of the content. */\r\n    this.maxSpan = maxSpan;\r\n  }\r\n\r\n  /** @override */\r\n  getSpan(b, offset) {\r\n    if (!Buffer.isBuffer(b)) {\r\n      throw new TypeError('b must be a Buffer');\r\n    }\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    return b.length - offset;\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset, dest) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    let span = this.getSpan(b, offset);\r\n    if ((0 <= this.maxSpan)\r\n        && (this.maxSpan < span)) {\r\n      throw new RangeError('text length exceeds maxSpan');\r\n    }\r\n    return b.slice(offset, offset + span).toString('utf-8');\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    if (undefined === offset) {\r\n      offset = 0;\r\n    }\r\n    /* Must force this to a string, lest it be a number and the\r\n     * \"utf8-encoding\" below actually allocate a buffer of length\r\n     * src */\r\n    if ('string' !== typeof src) {\r\n      src = src.toString();\r\n    }\r\n    const srcb = new Buffer(src, 'utf8');\r\n    const span = srcb.length;\r\n    if ((0 <= this.maxSpan)\r\n        && (this.maxSpan < span)) {\r\n      throw new RangeError('text length exceeds maxSpan');\r\n    }\r\n    if ((offset + span) > b.length) {\r\n      throw new RangeError('encoding overruns Buffer');\r\n    }\r\n    srcb.copy(b, offset);\r\n    return span;\r\n  }\r\n}\r\n\r\n/**\r\n * Contain a constant value.\r\n *\r\n * This layout may be used in cases where a JavaScript value can be\r\n * inferred without an expression in the binary encoding.  An example\r\n * would be a {@link VariantLayout|variant layout} where the content\r\n * is implied by the union {@link Union#discriminator|discriminator}.\r\n *\r\n * @param {Object|Number|String} value - initializer for {@link\r\n * Constant#value|value}.  If the value is an object (or array) and\r\n * the application intends the object to remain unchanged regardless\r\n * of what is done to values decoded by this layout, the value should\r\n * be frozen prior passing it to this constructor.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nclass Constant extends Layout {\r\n  constructor(value, property) {\r\n    super(0, property);\r\n\r\n    /** The value produced by this constant when the layout is {@link\r\n     * Constant#decode|decoded}.\r\n     *\r\n     * Any JavaScript value including `null` and `undefined` is\r\n     * permitted.\r\n     *\r\n     * **WARNING** If `value` passed in the constructor was not\r\n     * frozen, it is possible for users of decoded values to change\r\n     * the content of the value. */\r\n    this.value = value;\r\n  }\r\n\r\n  /** @override */\r\n  decode(b, offset, dest) {\r\n    return this.value;\r\n  }\r\n\r\n  /** @override */\r\n  encode(src, b, offset) {\r\n    /* Constants take no space */\r\n    return 0;\r\n  }\r\n}\r\n\r\nexports.ExternalLayout = ExternalLayout;\r\nexports.GreedyCount = GreedyCount;\r\nexports.OffsetLayout = OffsetLayout;\r\nexports.UInt = UInt;\r\nexports.UIntBE = UIntBE;\r\nexports.Int = Int;\r\nexports.IntBE = IntBE;\r\nexports.Float = Float;\r\nexports.FloatBE = FloatBE;\r\nexports.Double = Double;\r\nexports.DoubleBE = DoubleBE;\r\nexports.Sequence = Sequence;\r\nexports.Structure = Structure;\r\nexports.UnionDiscriminator = UnionDiscriminator;\r\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\r\nexports.Union = Union;\r\nexports.VariantLayout = VariantLayout;\r\nexports.BitStructure = BitStructure;\r\nexports.BitField = BitField;\r\nexports.Boolean = Boolean;\r\nexports.Blob = Blob;\r\nexports.CString = CString;\r\nexports.UTF8 = UTF8;\r\nexports.Constant = Constant;\r\n\r\n/** Factory for {@link GreedyCount}. */\r\nexports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));\r\n\r\n/** Factory for {@link OffsetLayout}. */\r\nexports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));\r\n\r\n/** Factory for {@link UInt|unsigned int layouts} spanning one\r\n * byte. */\r\nexports.u8 = (property => new UInt(1, property));\r\n\r\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning two bytes. */\r\nexports.u16 = (property => new UInt(2, property));\r\n\r\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning three bytes. */\r\nexports.u24 = (property => new UInt(3, property));\r\n\r\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning four bytes. */\r\nexports.u32 = (property => new UInt(4, property));\r\n\r\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning five bytes. */\r\nexports.u40 = (property => new UInt(5, property));\r\n\r\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning six bytes. */\r\nexports.u48 = (property => new UInt(6, property));\r\n\r\n/** Factory for {@link NearUInt64|little-endian unsigned int\r\n * layouts} interpreted as Numbers. */\r\nexports.nu64 = (property => new NearUInt64(property));\r\n\r\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning two bytes. */\r\nexports.u16be = (property => new UIntBE(2, property));\r\n\r\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning three bytes. */\r\nexports.u24be = (property => new UIntBE(3, property));\r\n\r\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning four bytes. */\r\nexports.u32be = (property => new UIntBE(4, property));\r\n\r\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning five bytes. */\r\nexports.u40be = (property => new UIntBE(5, property));\r\n\r\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning six bytes. */\r\nexports.u48be = (property => new UIntBE(6, property));\r\n\r\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\r\n * layouts} interpreted as Numbers. */\r\nexports.nu64be = (property => new NearUInt64BE(property));\r\n\r\n/** Factory for {@link Int|signed int layouts} spanning one\r\n * byte. */\r\nexports.s8 = (property => new Int(1, property));\r\n\r\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning two bytes. */\r\nexports.s16 = (property => new Int(2, property));\r\n\r\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning three bytes. */\r\nexports.s24 = (property => new Int(3, property));\r\n\r\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning four bytes. */\r\nexports.s32 = (property => new Int(4, property));\r\n\r\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning five bytes. */\r\nexports.s40 = (property => new Int(5, property));\r\n\r\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning six bytes. */\r\nexports.s48 = (property => new Int(6, property));\r\n\r\n/** Factory for {@link NearInt64|little-endian signed int layouts}\r\n * interpreted as Numbers. */\r\nexports.ns64 = (property => new NearInt64(property));\r\n\r\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning two bytes. */\r\nexports.s16be = (property => new IntBE(2, property));\r\n\r\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning three bytes. */\r\nexports.s24be = (property => new IntBE(3, property));\r\n\r\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning four bytes. */\r\nexports.s32be = (property => new IntBE(4, property));\r\n\r\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning five bytes. */\r\nexports.s40be = (property => new IntBE(5, property));\r\n\r\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning six bytes. */\r\nexports.s48be = (property => new IntBE(6, property));\r\n\r\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\r\n * interpreted as Numbers. */\r\nexports.ns64be = (property => new NearInt64BE(property));\r\n\r\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\r\nexports.f32 = (property => new Float(property));\r\n\r\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\r\nexports.f32be = (property => new FloatBE(property));\r\n\r\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\r\nexports.f64 = (property => new Double(property));\r\n\r\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\r\nexports.f64be = (property => new DoubleBE(property));\r\n\r\n/** Factory for {@link Structure} values. */\r\nexports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));\r\n\r\n/** Factory for {@link BitStructure} values. */\r\nexports.bits = ((word, msb, property) => new BitStructure(word, msb, property));\r\n\r\n/** Factory for {@link Sequence} values. */\r\nexports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));\r\n\r\n/** Factory for {@link Union} values. */\r\nexports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));\r\n\r\n/** Factory for {@link UnionLayoutDiscriminator} values. */\r\nexports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));\r\n\r\n/** Factory for {@link Blob} values. */\r\nexports.blob = ((length, property) => new Blob(length, property));\r\n\r\n/** Factory for {@link CString} values. */\r\nexports.cstr = (property => new CString(property));\r\n\r\n/** Factory for {@link UTF8} values. */\r\nexports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));\r\n\r\n/** Factory for {@link Constant} values. */\r\nexports.const = ((value, property) => new Constant(value, property));\r\n"]},"metadata":{},"sourceType":"script"}