{"ast":null,"code":"import _classCallCheck from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlError } from \"../error\";\nexport var IdlCoder = /*#__PURE__*/function () {\n  function IdlCoder() {\n    _classCallCheck(this, IdlCoder);\n  }\n\n  _createClass(IdlCoder, null, [{\n    key: \"fieldLayout\",\n    value: function fieldLayout(field, types) {\n      var fieldName = field.name !== undefined ? camelCase(field.name) : undefined;\n\n      switch (field.type) {\n        case \"bool\":\n          {\n            return borsh.bool(fieldName);\n          }\n\n        case \"u8\":\n          {\n            return borsh.u8(fieldName);\n          }\n\n        case \"i8\":\n          {\n            return borsh.i8(fieldName);\n          }\n\n        case \"u16\":\n          {\n            return borsh.u16(fieldName);\n          }\n\n        case \"i16\":\n          {\n            return borsh.i16(fieldName);\n          }\n\n        case \"u32\":\n          {\n            return borsh.u32(fieldName);\n          }\n\n        case \"i32\":\n          {\n            return borsh.i32(fieldName);\n          }\n\n        case \"u64\":\n          {\n            return borsh.u64(fieldName);\n          }\n\n        case \"i64\":\n          {\n            return borsh.i64(fieldName);\n          }\n\n        case \"u128\":\n          {\n            return borsh.u128(fieldName);\n          }\n\n        case \"i128\":\n          {\n            return borsh.i128(fieldName);\n          }\n\n        case \"bytes\":\n          {\n            return borsh.vecU8(fieldName);\n          }\n\n        case \"string\":\n          {\n            return borsh.str(fieldName);\n          }\n\n        case \"publicKey\":\n          {\n            return borsh.publicKey(fieldName);\n          }\n\n        default:\n          {\n            // @ts-ignore\n            if (field.type.vec) {\n              return borsh.vec(IdlCoder.fieldLayout({\n                name: undefined,\n                // @ts-ignore\n                type: field.type.vec\n              }, types), fieldName); // @ts-ignore\n            } else if (field.type.option) {\n              return borsh.option(IdlCoder.fieldLayout({\n                name: undefined,\n                // @ts-ignore\n                type: field.type.option\n              }, types), fieldName); // @ts-ignore\n            } else if (field.type.defined) {\n              // User defined type.\n              if (types === undefined) {\n                throw new IdlError(\"User defined types not provided\");\n              } // @ts-ignore\n\n\n              var filtered = types.filter(function (t) {\n                return t.name === field.type.defined;\n              });\n\n              if (filtered.length !== 1) {\n                throw new IdlError(\"Type not found: \".concat(JSON.stringify(field)));\n              }\n\n              return IdlCoder.typeDefLayout(filtered[0], types, fieldName); // @ts-ignore\n            } else if (field.type.array) {\n              // @ts-ignore\n              var arrayTy = field.type.array[0]; // @ts-ignore\n\n              var arrayLen = field.type.array[1];\n              var innerLayout = IdlCoder.fieldLayout({\n                name: undefined,\n                type: arrayTy\n              }, types);\n              return borsh.array(innerLayout, arrayLen, fieldName);\n            } else {\n              throw new Error(\"Not yet implemented: \".concat(field));\n            }\n          }\n      }\n    }\n  }, {\n    key: \"typeDefLayout\",\n    value: function typeDefLayout(typeDef, types, name) {\n      if (typeDef.type.kind === \"struct\") {\n        var fieldLayouts = typeDef.type.fields.map(function (field) {\n          var x = IdlCoder.fieldLayout(field, types);\n          return x;\n        });\n        return borsh.struct(fieldLayouts, name);\n      } else if (typeDef.type.kind === \"enum\") {\n        var variants = typeDef.type.variants.map(function (variant) {\n          var name = camelCase(variant.name);\n\n          if (variant.fields === undefined) {\n            return borsh.struct([], name);\n          } // @ts-ignore\n\n\n          var fieldLayouts = variant.fields.map(function (f) {\n            // @ts-ignore\n            if (f.name === undefined) {\n              throw new Error(\"Tuple enum variants not yet implemented.\");\n            } // @ts-ignore\n\n\n            return IdlCoder.fieldLayout(f, types);\n          });\n          return borsh.struct(fieldLayouts, name);\n        });\n\n        if (name !== undefined) {\n          // Buffer-layout lib requires the name to be null (on construction)\n          // when used as a field.\n          return borsh.rustEnum(variants).replicate(name);\n        }\n\n        return borsh.rustEnum(variants, name);\n      } else {\n        throw new Error(\"Unknown type kint: \".concat(typeDef));\n      }\n    }\n  }]);\n\n  return IdlCoder;\n}();","map":{"version":3,"sources":["../../../src/coder/idl.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\r\nimport * as borsh from \"@project-serum/borsh\";\r\nimport { IdlError } from \"../error\";\r\nexport class IdlCoder {\r\n    static fieldLayout(field, types) {\r\n        const fieldName = field.name !== undefined ? camelCase(field.name) : undefined;\r\n        switch (field.type) {\r\n            case \"bool\": {\r\n                return borsh.bool(fieldName);\r\n            }\r\n            case \"u8\": {\r\n                return borsh.u8(fieldName);\r\n            }\r\n            case \"i8\": {\r\n                return borsh.i8(fieldName);\r\n            }\r\n            case \"u16\": {\r\n                return borsh.u16(fieldName);\r\n            }\r\n            case \"i16\": {\r\n                return borsh.i16(fieldName);\r\n            }\r\n            case \"u32\": {\r\n                return borsh.u32(fieldName);\r\n            }\r\n            case \"i32\": {\r\n                return borsh.i32(fieldName);\r\n            }\r\n            case \"u64\": {\r\n                return borsh.u64(fieldName);\r\n            }\r\n            case \"i64\": {\r\n                return borsh.i64(fieldName);\r\n            }\r\n            case \"u128\": {\r\n                return borsh.u128(fieldName);\r\n            }\r\n            case \"i128\": {\r\n                return borsh.i128(fieldName);\r\n            }\r\n            case \"bytes\": {\r\n                return borsh.vecU8(fieldName);\r\n            }\r\n            case \"string\": {\r\n                return borsh.str(fieldName);\r\n            }\r\n            case \"publicKey\": {\r\n                return borsh.publicKey(fieldName);\r\n            }\r\n            default: {\r\n                // @ts-ignore\r\n                if (field.type.vec) {\r\n                    return borsh.vec(IdlCoder.fieldLayout({\r\n                        name: undefined,\r\n                        // @ts-ignore\r\n                        type: field.type.vec,\r\n                    }, types), fieldName);\r\n                    // @ts-ignore\r\n                }\r\n                else if (field.type.option) {\r\n                    return borsh.option(IdlCoder.fieldLayout({\r\n                        name: undefined,\r\n                        // @ts-ignore\r\n                        type: field.type.option,\r\n                    }, types), fieldName);\r\n                    // @ts-ignore\r\n                }\r\n                else if (field.type.defined) {\r\n                    // User defined type.\r\n                    if (types === undefined) {\r\n                        throw new IdlError(\"User defined types not provided\");\r\n                    }\r\n                    // @ts-ignore\r\n                    const filtered = types.filter((t) => t.name === field.type.defined);\r\n                    if (filtered.length !== 1) {\r\n                        throw new IdlError(`Type not found: ${JSON.stringify(field)}`);\r\n                    }\r\n                    return IdlCoder.typeDefLayout(filtered[0], types, fieldName);\r\n                    // @ts-ignore\r\n                }\r\n                else if (field.type.array) {\r\n                    // @ts-ignore\r\n                    let arrayTy = field.type.array[0];\r\n                    // @ts-ignore\r\n                    let arrayLen = field.type.array[1];\r\n                    let innerLayout = IdlCoder.fieldLayout({\r\n                        name: undefined,\r\n                        type: arrayTy,\r\n                    }, types);\r\n                    return borsh.array(innerLayout, arrayLen, fieldName);\r\n                }\r\n                else {\r\n                    throw new Error(`Not yet implemented: ${field}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static typeDefLayout(typeDef, types, name) {\r\n        if (typeDef.type.kind === \"struct\") {\r\n            const fieldLayouts = typeDef.type.fields.map((field) => {\r\n                const x = IdlCoder.fieldLayout(field, types);\r\n                return x;\r\n            });\r\n            return borsh.struct(fieldLayouts, name);\r\n        }\r\n        else if (typeDef.type.kind === \"enum\") {\r\n            let variants = typeDef.type.variants.map((variant) => {\r\n                const name = camelCase(variant.name);\r\n                if (variant.fields === undefined) {\r\n                    return borsh.struct([], name);\r\n                }\r\n                // @ts-ignore\r\n                const fieldLayouts = variant.fields.map((f) => {\r\n                    // @ts-ignore\r\n                    if (f.name === undefined) {\r\n                        throw new Error(\"Tuple enum variants not yet implemented.\");\r\n                    }\r\n                    // @ts-ignore\r\n                    return IdlCoder.fieldLayout(f, types);\r\n                });\r\n                return borsh.struct(fieldLayouts, name);\r\n            });\r\n            if (name !== undefined) {\r\n                // Buffer-layout lib requires the name to be null (on construction)\r\n                // when used as a field.\r\n                return borsh.rustEnum(variants).replicate(name);\r\n            }\r\n            return borsh.rustEnum(variants, name);\r\n        }\r\n        else {\r\n            throw new Error(`Unknown type kint: ${typeDef}`);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=idl.js.map"]},"metadata":{},"sourceType":"module"}