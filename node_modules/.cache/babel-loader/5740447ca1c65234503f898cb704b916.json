{"ast":null,"code":"import _asyncToGenerator from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _slicedToArray from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\nimport _classCallCheck from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport EventEmitter from \"eventemitter3\";\nimport camelCase from \"camelcase\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport Coder, { stateDiscriminator } from \"../../coder\";\nimport { getProvider } from \"../../\";\nimport { validateAccounts, parseIdlErrors } from \"../common\";\nimport { findProgramAddressSync, createWithSeedSync } from \"../../utils/pubkey\";\nimport InstructionNamespaceFactory from \"./instruction\";\nimport RpcNamespaceFactory from \"./rpc\";\nimport TransactionNamespaceFactory from \"./transaction\";\n\nvar StateFactory = /*#__PURE__*/function () {\n  function StateFactory() {\n    _classCallCheck(this, StateFactory);\n  }\n\n  _createClass(StateFactory, null, [{\n    key: \"build\",\n    value: function build(idl, coder, programId, provider) {\n      if (idl.state === undefined) {\n        return undefined;\n      }\n\n      return new StateClient(idl, programId, provider, coder);\n    }\n  }]);\n\n  return StateFactory;\n}();\n/**\r\n * A client for the program state. Similar to the base [[Program]] client,\r\n * one can use this to send transactions and read accounts for the state\r\n * abstraction.\r\n */\n\n\nexport { StateFactory as default };\nexport var StateClient = /*#__PURE__*/function () {\n  function StateClient(idl, programId, provider, coder) {\n    _classCallCheck(this, StateClient);\n\n    this._idl = idl;\n    this._programId = programId;\n    this._address = programStateAddress(programId);\n    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\n    this._sub = null; // Build namespaces.\n\n    var _ref = function () {\n      var instruction = {};\n      var transaction = {};\n      var rpc = {};\n      idl.state.methods.forEach(function (m) {\n        // Build instruction method.\n        var ixItem = InstructionNamespaceFactory.build(m, function (ixName, ix) {\n          return coder.instruction.encodeState(ixName, ix);\n        }, programId);\n\n        ixItem[\"accounts\"] = function (accounts) {\n          var keys = stateInstructionKeys(programId, provider, m, accounts);\n          return keys.concat(InstructionNamespaceFactory.accountsArray(accounts, m.accounts));\n        }; // Build transaction method.\n\n\n        // Build transaction method.\n        var txItem = TransactionNamespaceFactory.build(m, ixItem); // Build RPC method.\n\n        // Build RPC method.\n        var rpcItem = RpcNamespaceFactory.build(m, txItem, parseIdlErrors(idl), provider); // Attach them all to their respective namespaces.\n\n        // Attach them all to their respective namespaces.\n        var name = camelCase(m.name);\n        instruction[name] = ixItem;\n        transaction[name] = txItem;\n        rpc[name] = rpcItem;\n      });\n      return [instruction, transaction, rpc];\n    }(),\n        _ref2 = _slicedToArray(_ref, 3),\n        instruction = _ref2[0],\n        transaction = _ref2[1],\n        rpc = _ref2[2];\n\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.rpc = rpc;\n  }\n  /**\r\n   * Returns the program ID owning the state.\r\n   */\n\n\n  _createClass(StateClient, [{\n    key: \"programId\",\n    get: function get() {\n      return this._programId;\n    }\n    /**\r\n     * Returns the client's wallet and network provider.\r\n     */\n\n  }, {\n    key: \"provider\",\n    get: function get() {\n      return this._provider;\n    }\n    /**\r\n     * Returns the coder.\r\n     */\n\n  }, {\n    key: \"coder\",\n    get: function get() {\n      return this._coder;\n    }\n    /**\r\n     * Returns the deserialized state account.\r\n     */\n\n  }, {\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var addr, accountInfo, expectedDiscriminator;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                addr = this.address();\n                _context.next = 3;\n                return this.provider.connection.getAccountInfo(addr);\n\n              case 3:\n                accountInfo = _context.sent;\n\n                if (!(accountInfo === null)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw new Error(\"Account does not exist \".concat(addr.toString()));\n\n              case 6:\n                _context.next = 8;\n                return stateDiscriminator(this._idl.state.struct.name);\n\n              case 8:\n                expectedDiscriminator = _context.sent;\n\n                if (!expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n                  _context.next = 11;\n                  break;\n                }\n\n                throw new Error(\"Invalid account discriminator\");\n\n              case 11:\n                return _context.abrupt(\"return\", this.coder.state.decode(accountInfo.data));\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function fetch() {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n    /**\r\n     * Returns the state address.\r\n     */\n\n  }, {\n    key: \"address\",\n    value: function address() {\n      return this._address;\n    }\n    /**\r\n     * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\r\n     * the state account cahnges.\r\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(commitment) {\n      var _this = this;\n\n      if (this._sub !== null) {\n        return this._sub.ee;\n      }\n\n      var ee = new EventEmitter();\n      var listener = this.provider.connection.onAccountChange(this.address(), function (acc) {\n        var account = _this.coder.state.decode(acc.data);\n\n        ee.emit(\"change\", account);\n      }, commitment);\n      this._sub = {\n        ee: ee,\n        listener: listener\n      };\n      return ee;\n    }\n    /**\r\n     * Unsubscribes to state changes.\r\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this2 = this;\n\n      if (this._sub !== null) {\n        this.provider.connection.removeAccountChangeListener(this._sub.listener).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _this2._sub = null;\n\n                case 1:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }))).catch(console.error);\n      }\n    }\n  }]);\n\n  return StateClient;\n}(); // Calculates the deterministic address of the program's \"state\" account.\n\nfunction programStateAddress(programId) {\n  var _findProgramAddressSy = findProgramAddressSync([], programId),\n      _findProgramAddressSy2 = _slicedToArray(_findProgramAddressSy, 1),\n      registrySigner = _findProgramAddressSy2[0];\n\n  return createWithSeedSync(registrySigner, \"unversioned\", programId);\n} // Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\n\n\nfunction stateInstructionKeys(programId, provider, m, accounts) {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    var _findProgramAddressSy3 = findProgramAddressSync([], programId),\n        _findProgramAddressSy4 = _slicedToArray(_findProgramAddressSy3, 1),\n        programSigner = _findProgramAddressSy4[0];\n\n    return [{\n      pubkey: provider.wallet.publicKey,\n      isWritable: false,\n      isSigner: true\n    }, {\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: programSigner,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: SystemProgram.programId,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: programId,\n      isWritable: false,\n      isSigner: false\n    }];\n  } else {\n    validateAccounts(m.accounts, accounts);\n    return [{\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }];\n  }\n}","map":{"version":3,"sources":["../../../../src/program/namespace/state.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import EventEmitter from \"eventemitter3\";\r\nimport camelCase from \"camelcase\";\r\nimport { SystemProgram } from \"@solana/web3.js\";\r\nimport Coder, { stateDiscriminator } from \"../../coder\";\r\nimport { getProvider } from \"../../\";\r\nimport { validateAccounts, parseIdlErrors } from \"../common\";\r\nimport { findProgramAddressSync, createWithSeedSync } from \"../../utils/pubkey\";\r\nimport InstructionNamespaceFactory from \"./instruction\";\r\nimport RpcNamespaceFactory from \"./rpc\";\r\nimport TransactionNamespaceFactory from \"./transaction\";\r\nexport default class StateFactory {\r\n    static build(idl, coder, programId, provider) {\r\n        if (idl.state === undefined) {\r\n            return undefined;\r\n        }\r\n        return new StateClient(idl, programId, provider, coder);\r\n    }\r\n}\r\n/**\r\n * A client for the program state. Similar to the base [[Program]] client,\r\n * one can use this to send transactions and read accounts for the state\r\n * abstraction.\r\n */\r\nexport class StateClient {\r\n    constructor(idl, programId, provider, coder) {\r\n        this._idl = idl;\r\n        this._programId = programId;\r\n        this._address = programStateAddress(programId);\r\n        this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\r\n        this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\r\n        this._sub = null;\r\n        // Build namespaces.\r\n        const [instruction, transaction, rpc] = (() => {\r\n            let instruction = {};\r\n            let transaction = {};\r\n            let rpc = {};\r\n            idl.state.methods.forEach((m) => {\r\n                // Build instruction method.\r\n                const ixItem = InstructionNamespaceFactory.build(m, (ixName, ix) => coder.instruction.encodeState(ixName, ix), programId);\r\n                ixItem[\"accounts\"] = (accounts) => {\r\n                    const keys = stateInstructionKeys(programId, provider, m, accounts);\r\n                    return keys.concat(InstructionNamespaceFactory.accountsArray(accounts, m.accounts));\r\n                };\r\n                // Build transaction method.\r\n                const txItem = TransactionNamespaceFactory.build(m, ixItem);\r\n                // Build RPC method.\r\n                const rpcItem = RpcNamespaceFactory.build(m, txItem, parseIdlErrors(idl), provider);\r\n                // Attach them all to their respective namespaces.\r\n                const name = camelCase(m.name);\r\n                instruction[name] = ixItem;\r\n                transaction[name] = txItem;\r\n                rpc[name] = rpcItem;\r\n            });\r\n            return [instruction, transaction, rpc];\r\n        })();\r\n        this.instruction = instruction;\r\n        this.transaction = transaction;\r\n        this.rpc = rpc;\r\n    }\r\n    /**\r\n     * Returns the program ID owning the state.\r\n     */\r\n    get programId() {\r\n        return this._programId;\r\n    }\r\n    /**\r\n     * Returns the client's wallet and network provider.\r\n     */\r\n    get provider() {\r\n        return this._provider;\r\n    }\r\n    /**\r\n     * Returns the coder.\r\n     */\r\n    get coder() {\r\n        return this._coder;\r\n    }\r\n    /**\r\n     * Returns the deserialized state account.\r\n     */\r\n    async fetch() {\r\n        const addr = this.address();\r\n        const accountInfo = await this.provider.connection.getAccountInfo(addr);\r\n        if (accountInfo === null) {\r\n            throw new Error(`Account does not exist ${addr.toString()}`);\r\n        }\r\n        // Assert the account discriminator is correct.\r\n        const expectedDiscriminator = await stateDiscriminator(this._idl.state.struct.name);\r\n        if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\r\n            throw new Error(\"Invalid account discriminator\");\r\n        }\r\n        return this.coder.state.decode(accountInfo.data);\r\n    }\r\n    /**\r\n     * Returns the state address.\r\n     */\r\n    address() {\r\n        return this._address;\r\n    }\r\n    /**\r\n     * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\r\n     * the state account cahnges.\r\n     */\r\n    subscribe(commitment) {\r\n        if (this._sub !== null) {\r\n            return this._sub.ee;\r\n        }\r\n        const ee = new EventEmitter();\r\n        const listener = this.provider.connection.onAccountChange(this.address(), (acc) => {\r\n            const account = this.coder.state.decode(acc.data);\r\n            ee.emit(\"change\", account);\r\n        }, commitment);\r\n        this._sub = {\r\n            ee,\r\n            listener,\r\n        };\r\n        return ee;\r\n    }\r\n    /**\r\n     * Unsubscribes to state changes.\r\n     */\r\n    unsubscribe() {\r\n        if (this._sub !== null) {\r\n            this.provider.connection\r\n                .removeAccountChangeListener(this._sub.listener)\r\n                .then(async () => {\r\n                this._sub = null;\r\n            })\r\n                .catch(console.error);\r\n        }\r\n    }\r\n}\r\n// Calculates the deterministic address of the program's \"state\" account.\r\nfunction programStateAddress(programId) {\r\n    let [registrySigner] = findProgramAddressSync([], programId);\r\n    return createWithSeedSync(registrySigner, \"unversioned\", programId);\r\n}\r\n// Returns the common keys that are prepended to all instructions targeting\r\n// the \"state\" of a program.\r\nfunction stateInstructionKeys(programId, provider, m, accounts) {\r\n    if (m.name === \"new\") {\r\n        // Ctor `new` method.\r\n        const [programSigner] = findProgramAddressSync([], programId);\r\n        return [\r\n            {\r\n                pubkey: provider.wallet.publicKey,\r\n                isWritable: false,\r\n                isSigner: true,\r\n            },\r\n            {\r\n                pubkey: programStateAddress(programId),\r\n                isWritable: true,\r\n                isSigner: false,\r\n            },\r\n            { pubkey: programSigner, isWritable: false, isSigner: false },\r\n            {\r\n                pubkey: SystemProgram.programId,\r\n                isWritable: false,\r\n                isSigner: false,\r\n            },\r\n            { pubkey: programId, isWritable: false, isSigner: false },\r\n        ];\r\n    }\r\n    else {\r\n        validateAccounts(m.accounts, accounts);\r\n        return [\r\n            {\r\n                pubkey: programStateAddress(programId),\r\n                isWritable: true,\r\n                isSigner: false,\r\n            },\r\n        ];\r\n    }\r\n}\r\n//# sourceMappingURL=state.js.map"]},"metadata":{},"sourceType":"module"}