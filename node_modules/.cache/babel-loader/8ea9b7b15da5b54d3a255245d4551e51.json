{"ast":null,"code":"import _asyncToGenerator from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _slicedToArray from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\nimport _classCallCheck from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"D:\\\\Lianok\\\\dev\\\\new-project\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport { inflate } from \"pako\";\nimport { idlAddress, decodeIdlAccount } from \"../idl\";\nimport Coder from \"../coder\";\nimport NamespaceFactory from \"./namespace\";\nimport { getProvider } from \"../\";\nimport { utf8 } from \"../utils/bytes\";\nimport { EventManager } from \"./event\";\nimport { translateAddress } from \"./common\";\n/**\r\n * ## Program\r\n *\r\n * Program provides the IDL deserialized client representation of an Anchor\r\n * program.\r\n *\r\n * This API is the one stop shop for all things related to communicating with\r\n * on-chain programs. Among other things, one can send transactions, fetch\r\n * deserialized accounts, decode instruction data, subscribe to account\r\n * changes, and listen to events.\r\n *\r\n * In addition to field accessors and methods, the object provides a set of\r\n * dynamically generated properties, also known as namespaces, that\r\n * map one-to-one to program methods and accounts. These namespaces generally\r\n *  can be used as follows:\r\n *\r\n * ## Usage\r\n *\r\n * ```javascript\r\n * program.<namespace>.<program-specific-method>\r\n * ```\r\n *\r\n * API specifics are namespace dependent. The examples used in the documentation\r\n * below will refer to the two counter examples found\r\n * [here](https://github.com/project-serum/anchor#examples).\r\n */\n\nexport var Program = /*#__PURE__*/function () {\n  /**\r\n   * @param idl       The interface definition.\r\n   * @param programId The on-chain address of the program.\r\n   * @param provider  The network and wallet context to use. If not provided\r\n   *                  then uses [[getProvider]].\r\n   */\n  function Program(idl, programId, provider) {\n    _classCallCheck(this, Program);\n\n    programId = translateAddress(programId); // Fields.\n\n    this._idl = idl;\n    this._programId = programId;\n    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    this._coder = new Coder(idl);\n    this._events = new EventManager(this._programId, this._provider, this._coder); // Dynamic namespaces.\n\n    var _NamespaceFactory$bui = NamespaceFactory.build(idl, this._coder, programId, this._provider),\n        _NamespaceFactory$bui2 = _slicedToArray(_NamespaceFactory$bui, 6),\n        rpc = _NamespaceFactory$bui2[0],\n        instruction = _NamespaceFactory$bui2[1],\n        transaction = _NamespaceFactory$bui2[2],\n        account = _NamespaceFactory$bui2[3],\n        simulate = _NamespaceFactory$bui2[4],\n        state = _NamespaceFactory$bui2[5];\n\n    this.rpc = rpc;\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.account = account;\n    this.simulate = simulate;\n    this.state = state;\n  }\n  /**\r\n   * Address of the program.\r\n   */\n\n\n  _createClass(Program, [{\n    key: \"programId\",\n    get: function get() {\n      return this._programId;\n    }\n    /**\r\n     * IDL defining the program's interface.\r\n     */\n\n  }, {\n    key: \"idl\",\n    get: function get() {\n      return this._idl;\n    }\n    /**\r\n     * Coder for serializing requests.\r\n     */\n\n  }, {\n    key: \"coder\",\n    get: function get() {\n      return this._coder;\n    }\n    /**\r\n     * Wallet and network provider.\r\n     */\n\n  }, {\n    key: \"provider\",\n    get: function get() {\n      return this._provider;\n    }\n    /**\r\n     * Generates a Program client by fetching the IDL from the network.\r\n     *\r\n     * In order to use this method, an IDL must have been previously initialized\r\n     * via the anchor CLI's `anchor idl init` command.\r\n     *\r\n     * @param programId The on-chain address of the program.\r\n     * @param provider  The network and wallet context.\r\n     */\n\n  }, {\n    key: \"addEventListener\",\n    value:\n    /**\r\n     * Invokes the given callback every time the given event is emitted.\r\n     *\r\n     * @param eventName The PascalCase name of the event, provided by the IDL.\r\n     * @param callback  The function to invoke whenever the event is emitted from\r\n     *                  program logs.\r\n     */\n    function addEventListener(eventName, callback) {\n      return this._events.addEventListener(eventName, callback);\n    }\n    /**\r\n     * Unsubscribes from the given eventName.\r\n     */\n\n  }, {\n    key: \"removeEventListener\",\n    value: function () {\n      var _removeEventListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(listener) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._events.removeEventListener(listener);\n\n              case 2:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function removeEventListener(_x) {\n        return _removeEventListener.apply(this, arguments);\n      }\n\n      return removeEventListener;\n    }()\n  }], [{\n    key: \"at\",\n    value: function () {\n      var _at = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address, provider) {\n        var programId, idl;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                programId = translateAddress(address);\n                _context2.next = 3;\n                return Program.fetchIdl(programId, provider);\n\n              case 3:\n                idl = _context2.sent;\n                return _context2.abrupt(\"return\", new Program(idl, programId, provider));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function at(_x2, _x3) {\n        return _at.apply(this, arguments);\n      }\n\n      return at;\n    }()\n    /**\r\n     * Fetches an idl from the blockchain.\r\n     *\r\n     * In order to use this method, an IDL must have been previously initialized\r\n     * via the anchor CLI's `anchor idl init` command.\r\n     *\r\n     * @param programId The on-chain address of the program.\r\n     * @param provider  The network and wallet context.\r\n     */\n\n  }, {\n    key: \"fetchIdl\",\n    value: function () {\n      var _fetchIdl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(address, provider) {\n        var programId, idlAddr, accountInfo, idlAccount, inflatedIdl;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                provider = provider !== null && provider !== void 0 ? provider : getProvider();\n                programId = translateAddress(address);\n                _context3.next = 4;\n                return idlAddress(programId);\n\n              case 4:\n                idlAddr = _context3.sent;\n                _context3.next = 7;\n                return provider.connection.getAccountInfo(idlAddr);\n\n              case 7:\n                accountInfo = _context3.sent;\n                // Chop off account discriminator.\n                idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n                inflatedIdl = inflate(idlAccount.data);\n                return _context3.abrupt(\"return\", JSON.parse(utf8.decode(inflatedIdl)));\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function fetchIdl(_x4, _x5) {\n        return _fetchIdl.apply(this, arguments);\n      }\n\n      return fetchIdl;\n    }()\n  }]);\n\n  return Program;\n}();","map":{"version":3,"sources":["../../../src/program/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { inflate } from \"pako\";\r\nimport { idlAddress, decodeIdlAccount } from \"../idl\";\r\nimport Coder from \"../coder\";\r\nimport NamespaceFactory from \"./namespace\";\r\nimport { getProvider } from \"../\";\r\nimport { utf8 } from \"../utils/bytes\";\r\nimport { EventManager } from \"./event\";\r\nimport { translateAddress } from \"./common\";\r\n/**\r\n * ## Program\r\n *\r\n * Program provides the IDL deserialized client representation of an Anchor\r\n * program.\r\n *\r\n * This API is the one stop shop for all things related to communicating with\r\n * on-chain programs. Among other things, one can send transactions, fetch\r\n * deserialized accounts, decode instruction data, subscribe to account\r\n * changes, and listen to events.\r\n *\r\n * In addition to field accessors and methods, the object provides a set of\r\n * dynamically generated properties, also known as namespaces, that\r\n * map one-to-one to program methods and accounts. These namespaces generally\r\n *  can be used as follows:\r\n *\r\n * ## Usage\r\n *\r\n * ```javascript\r\n * program.<namespace>.<program-specific-method>\r\n * ```\r\n *\r\n * API specifics are namespace dependent. The examples used in the documentation\r\n * below will refer to the two counter examples found\r\n * [here](https://github.com/project-serum/anchor#examples).\r\n */\r\nexport class Program {\r\n    /**\r\n     * @param idl       The interface definition.\r\n     * @param programId The on-chain address of the program.\r\n     * @param provider  The network and wallet context to use. If not provided\r\n     *                  then uses [[getProvider]].\r\n     */\r\n    constructor(idl, programId, provider) {\r\n        programId = translateAddress(programId);\r\n        // Fields.\r\n        this._idl = idl;\r\n        this._programId = programId;\r\n        this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\r\n        this._coder = new Coder(idl);\r\n        this._events = new EventManager(this._programId, this._provider, this._coder);\r\n        // Dynamic namespaces.\r\n        const [rpc, instruction, transaction, account, simulate, state,] = NamespaceFactory.build(idl, this._coder, programId, this._provider);\r\n        this.rpc = rpc;\r\n        this.instruction = instruction;\r\n        this.transaction = transaction;\r\n        this.account = account;\r\n        this.simulate = simulate;\r\n        this.state = state;\r\n    }\r\n    /**\r\n     * Address of the program.\r\n     */\r\n    get programId() {\r\n        return this._programId;\r\n    }\r\n    /**\r\n     * IDL defining the program's interface.\r\n     */\r\n    get idl() {\r\n        return this._idl;\r\n    }\r\n    /**\r\n     * Coder for serializing requests.\r\n     */\r\n    get coder() {\r\n        return this._coder;\r\n    }\r\n    /**\r\n     * Wallet and network provider.\r\n     */\r\n    get provider() {\r\n        return this._provider;\r\n    }\r\n    /**\r\n     * Generates a Program client by fetching the IDL from the network.\r\n     *\r\n     * In order to use this method, an IDL must have been previously initialized\r\n     * via the anchor CLI's `anchor idl init` command.\r\n     *\r\n     * @param programId The on-chain address of the program.\r\n     * @param provider  The network and wallet context.\r\n     */\r\n    static async at(address, provider) {\r\n        const programId = translateAddress(address);\r\n        const idl = await Program.fetchIdl(programId, provider);\r\n        return new Program(idl, programId, provider);\r\n    }\r\n    /**\r\n     * Fetches an idl from the blockchain.\r\n     *\r\n     * In order to use this method, an IDL must have been previously initialized\r\n     * via the anchor CLI's `anchor idl init` command.\r\n     *\r\n     * @param programId The on-chain address of the program.\r\n     * @param provider  The network and wallet context.\r\n     */\r\n    static async fetchIdl(address, provider) {\r\n        provider = provider !== null && provider !== void 0 ? provider : getProvider();\r\n        const programId = translateAddress(address);\r\n        const idlAddr = await idlAddress(programId);\r\n        const accountInfo = await provider.connection.getAccountInfo(idlAddr);\r\n        // Chop off account discriminator.\r\n        let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\r\n        const inflatedIdl = inflate(idlAccount.data);\r\n        return JSON.parse(utf8.decode(inflatedIdl));\r\n    }\r\n    /**\r\n     * Invokes the given callback every time the given event is emitted.\r\n     *\r\n     * @param eventName The PascalCase name of the event, provided by the IDL.\r\n     * @param callback  The function to invoke whenever the event is emitted from\r\n     *                  program logs.\r\n     */\r\n    addEventListener(eventName, callback) {\r\n        return this._events.addEventListener(eventName, callback);\r\n    }\r\n    /**\r\n     * Unsubscribes from the given eventName.\r\n     */\r\n    async removeEventListener(listener) {\r\n        return await this._events.removeEventListener(listener);\r\n    }\r\n}\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}